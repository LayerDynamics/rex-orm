Certainly! Below is an even more expanded version of the original Rex-ORM guide, further enriching each section with additional details, comprehensive explanations, and full code examples. This expansion delves deeper into advanced relationship handling, detailed migration practices, sophisticated transaction management, extended design patterns, enhanced testing strategies, robust logging mechanisms, security considerations, performance optimizations, and more.

Rex-ORM: An In-Depth Guide
== Requirements
Below are the requirements for Rex-ORM, broken down into Must-Have, Should-Have, and Could-Have categories. These requirements will guide our design decisions and implementation to ensure that Rex-ORM is comprehensive, extensible, and production-ready.

=== Must-Have
Database Connectivity

PostgreSQL Support: Utilize Denoâ€™s PostgreSQL driver with efficient connection pooling.
SQLite Support: Provide a lightweight adapter for embedded or local development.
Connection Pooling: Allow multiple concurrent requests via a pool of connections (at least for PostgreSQL).
Transaction Management: Expose simple functions to handle BEGIN, COMMIT, and ROLLBACK.
Type Safety

Leverage TypeScript: Strongly typed models, queries, and results.
Strict Mode: Project must run in TypeScript strict mode ("strict": true in tsconfig).
CRUD Operations

Create, Read, Update, Delete: Provide intuitive, flexible APIs for each operation.
Batch Operations: Potentially allow multiple insert or update statements in a single call for performance.
Query Builder

Fluent, Chainable API: e.g. select('*').from('users').where('id','=',1).execute().
Joins, Grouping, Aggregation: Support JOIN, GROUP BY, HAVING, and aggregated columns like COUNT, SUM, etc.
Schema Definition

Decorators: Let developers mark classes as entities (@Entity) and define columns (@Column).
Reflect Metadata: Internally store table and column metadata using reflect metadata APIs.
Basic Relationships

One-to-One, One-to-Many, Many-to-Many: Provide decorators (@OneToOne, @OneToMany, @ManyToMany) or configuration options.
Lazy/Eager Loading: Where feasible, allow loading of related entities automatically.
Error Handling

Domain-Specific Errors: Throw errors like QueryError, MigrationError with clear explanations.
Catch-all Mechanism: Provide a top-level way to handle unexpected errors gracefully.
Extensibility

Modular Design: Make each feature pluggable or replaceable.
Plugin Architecture: Official plugin loading for additional databases, features (caching, advanced logging, etc.).
=== Should-Have
Migrations

Schema Migrations: Provide scripts and utilities to create, apply, rollback schema changes.
Migration History: Maintain a table to track the migrations that have already been applied.
Custom Queries

Raw SQL: Expose a method for executing raw SQL statements when specialized performance or structure is needed.
Validation

Decorators: e.g. @IsEmail(), @IsNumeric().
Runtime Checks: Validate data before writing to the database.
Logging

Configurable Logging: Output SQL queries and parameters at different log levels (debug, info, warn, error).
Hooks: Possibly provide a callback or plugin approach for custom logging.
CLI Tool

Commands: migrate, rollback, generate:model, etc.
Automatic Scaffolding: Possibly create an initial folder structure or sample files for new projects.
=== Could-Have
Caching

Simple Cache: Cache results of frequently run queries.
Invalidation Hooks: Provide ways to invalidate or refresh data automatically when writes occur.
NoSQL Support

MongoDB or Others: Potential expansions for non-relational databases as part of the plugin architecture.
Advanced Transaction Management

Nested Transactions: Support for savepoints and nested transactions.
Distributed Transactions: Integrate with transaction coordinators for multi-database operations.
Advanced Query Features

Subqueries: Allow building and executing subqueries within main queries.
Window Functions: Support for window functions like ROW_NUMBER(), RANK(), etc.
== Method
We adopt a modular architecture in TypeScript, ensuring each feature is clearly separated. This approach promotes clarity, testability, and maintainability. As the project grows, new modules (adapters, migrations, CLI commands) can be added without affecting existing functionality.

=== Architecture Overview
Core Modules:

Database Connector

Adapters for PostgreSQL and SQLite, with a factory for easy initialization.
Provides connection pooling (for PostgreSQL) and direct connections (for SQLite).
Manages transactions, resource cleanup, and error handling at the driver level.
Model Layer

Decorators for describing entity/table relationships, columns, primary keys, etc.
Storage of metadata via reflect metadata.
Optional validation decorators.
Query Builder

Chainable, fluent API for building advanced SQL statements.
Manages complex queries with joins, where clauses, ordering, grouping, etc.
Migration System

Script-based migrations (TypeScript files) defining up and down.
A runner/tracker that stores migration history in a dedicated table.
Plugin System

Simple mechanism for registering external modules that extend Rex-ORM capabilities.
CLI Tool

Automates common tasks (running migrations, generating models).
Hooks into the migration system and possibly the query builder for debugging.
Validation System

Runs data validations before database operations.
Integrates with model decorators for seamless validation.
Logging System

Configurable logging with different levels.
Supports multiple logging backends via plugins.
=== Technical Components
==== Database Connector
High-level Goals:

Provide a consistent interface (DatabaseAdapter) across different databases.
Offer uniform connect(), disconnect(), execute(query, params), and transaction methods.
Connection Pooling:

For PostgreSQL, use a client pooling approach (some drivers or libraries provide a pool automatically).
For SQLite, a pool is usually unnecessary (it is file-based or memory-based).
Transactions:

Common pattern:
typescript
Copy code
await adapter.beginTransaction();
try {
  await doSomeDatabaseWork();
  await adapter.commitTransaction();
} catch (err) {
  await adapter.rollbackTransaction();
  throw err;
}
Advanced Transactions:

Nested Transactions:

typescript
Copy code
// FILE: src/adapters/interfaces/DatabaseAdapter.ts
export interface DatabaseAdapter {
  // ... existing methods
  savepoint(name: string): Promise<void>;
  releaseSavepoint(name: string): Promise<void>;
  rollbackToSavepoint(name: string): Promise<void>;
}
typescript
Copy code
// Usage Example
await adapter.beginTransaction();
try {
  // Perform operations
  await adapter.savepoint("sp1");
  try {
    // Nested operations
  } catch (err) {
    await adapter.rollbackToSavepoint("sp1");
  }
  await adapter.commitTransaction();
} catch (err) {
  await adapter.rollbackTransaction();
  throw err;
}
Distributed Transactions:

Implementing two-phase commit or integrating with transaction coordinators.
Note: This is advanced and may require external services or additional protocols.
==== Model Layer
Reflect Metadata:

Store table name, columns, relationships in metadata.
This metadata is crucial for generating queries or performing schema introspection (in advanced features).
Validation (optional):

Provide decorators such as @IsEmail(), @Length(min, max).
Implemented using external libraries or a custom approach that runs before save() operations.
Example Validation Decorators:

typescript
Copy code
// FILE: src/models/validation.ts
export function IsEmail() {
  return function (target: any, propertyKey: string) {
    Reflect.defineMetadata(`validate:${propertyKey}`, "email", target.constructor);
  };
}

export function Length(min: number, max: number) {
  return function (target: any, propertyKey: string) {
    Reflect.defineMetadata(`validate:${propertyKey}`, { min, max }, target.constructor);
  };
}
Model Repository Integration:

typescript
Copy code
// FILE: src/models/Repository.ts
import { DatabaseAdapter } from "../adapters/interfaces/DatabaseAdapter.ts";
import "https://deno.land/x/reflect_metadata@v0.1.12/mod.ts";

export class Repository<T> {
  constructor(private adapter: DatabaseAdapter, private model: { new (): T }) {}

  async save(entity: T): Promise<void> {
    // Validate entity
    const validations = Reflect.getMetadata("validations", this.model) || {};
    for (const [property, rule] of Object.entries(validations)) {
      const value = (entity as any)[property];
      if (rule === "email" && !validateEmail(value)) {
        throw new ValidationError(`Invalid email format for ${property}`);
      }
      if (typeof rule === "object") {
        const { min, max } = rule;
        if (value.length < min || value.length > max) {
          throw new ValidationError(`Length of ${property} must be between ${min} and ${max}`);
        }
      }
    }

    // Proceed with saving
    // ...
  }

  // Additional CRUD methods
}

function validateEmail(email: string): boolean {
  const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return re.test(email);
}
==== Query Builder
Fluent API:

select(['id', 'name']).from('users').where('id', '=', 1).execute(adapter)
Support for placeholders and bound parameters to avoid SQL injection.
Advanced Features:

JOIN, LEFT JOIN, GROUP BY, HAVING, ORDER BY, LIMIT, OFFSET, etc.
Aggregates: COUNT, SUM, MAX, MIN, etc.
Subqueries for advanced usage.
Example with Subqueries and Window Functions:

typescript
Copy code
// FILE: src/query/AdvancedQueryBuilder.ts
import { DatabaseAdapter } from "../adapters/interfaces/DatabaseAdapter.ts";

export class AdvancedQueryBuilder extends QueryBuilder {
  // Existing methods...

  windowFunction(func: string, alias: string, partitionBy?: string, orderBy?: string) {
    const window = `${func} OVER (${partitionBy ? `PARTITION BY ${partitionBy} ` : ""}${orderBy ? `ORDER BY ${orderBy}` : ""}) AS ${alias}`;
    this._select.push(window);
    return this;
  }

  subquery(subBuilder: QueryBuilder, alias: string) {
    const subQuery = `(${subBuilder.buildQuery()}) AS ${alias}`;
    this._select.push(subQuery);
    return this;
  }
}

// Usage Example
const subQB = new QueryBuilder()
  .select('id')
  .from('users')
  .where('active', '=', true);

const qb = new AdvancedQueryBuilder()
  .select('name')
  .subquery(subQB, 'active_users')
  .from('users')
  .execute(adapter);
==== Migration System
Migration Runner

Manages applying and rolling back migrations in the correct order.
Ensures migrations are idempotent and maintains migration history.
typescript
Copy code
// FILE: src/migrations/MigrationRunner.ts
import { DatabaseAdapter } from "../adapters/interfaces/DatabaseAdapter.ts";

export class MigrationRunner {
  private migrationTable = "migration_history";

  constructor(private adapter: DatabaseAdapter) {}

  async initializeMigrationTable() {
    const createTableQuery = `
      CREATE TABLE IF NOT EXISTS ${this.migrationTable} (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL UNIQUE,
        applied_at TIMESTAMP DEFAULT NOW()
      )
    `;
    await this.adapter.execute(createTableQuery);
  }

  async getAppliedMigrations(): Promise<Set<string>> {
    const rows = await this.adapter.execute(`SELECT name FROM ${this.migrationTable}`);
    return new Set(rows.map((row: any) => row.name));
  }

  async applyMigrations(migrations: any[]) {
    await this.initializeMigrationTable();
    const applied = await this.getAppliedMigrations();

    for (const migration of migrations) {
      if (!applied.has(migration.name)) {
        await this.adapter.beginTransaction();
        try {
          await migration.up(this.adapter);
          await this.adapter.execute(`INSERT INTO ${this.migrationTable} (name) VALUES ($1)`, [migration.name]);
          await this.adapter.commitTransaction();
          console.log(`Applied migration: ${migration.name}`);
        } catch (err) {
          await this.adapter.rollbackTransaction();
          throw new MigrationError(`Failed to apply migration ${migration.name}: ${err.message}`);
        }
      }
    }
  }

  async rollbackMigrations(migrations: any[]) {
    await this.initializeMigrationTable();
    const applied = await this.getAppliedMigrations();

    for (const migration of migrations.reverse()) {
      if (applied.has(migration.name)) {
        await this.adapter.beginTransaction();
        try {
          await migration.down(this.adapter);
          await this.adapter.execute(`DELETE FROM ${this.migrationTable} WHERE name = $1`, [migration.name]);
          await this.adapter.commitTransaction();
          console.log(`Rolled back migration: ${migration.name}`);
        } catch (err) {
          await this.adapter.rollbackTransaction();
          throw new MigrationError(`Failed to rollback migration ${migration.name}: ${err.message}`);
        }
      }
    }
  }
}

// Custom Error
export class MigrationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "MigrationError";
  }
}
Example Migration with Indexes and Constraints

typescript
Copy code
// FILE: src/migrations/2_create_posts_table.ts
export default {
  name: "2_create_posts_table",
  up: async (db: any) => {
    await db.execute(`
      CREATE TABLE IF NOT EXISTS posts (
        id SERIAL PRIMARY KEY,
        title VARCHAR(255) NOT NULL,
        content TEXT NOT NULL,
        user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    await db.execute(`CREATE INDEX idx_posts_user_id ON posts(user_id)`);
  },
  down: async (db: any) => {
    await db.execute(`DROP INDEX IF EXISTS idx_posts_user_id;`);
    await db.execute(`DROP TABLE IF EXISTS posts;`);
  },
};
Migration History Table Initialization

typescript
Copy code
// FILE: src/migrations/0_init_migration_table.ts
export default {
  name: "0_init_migration_table",
  up: async (db: any) => {
    await db.execute(`
      CREATE TABLE IF NOT EXISTS migration_history (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL UNIQUE,
        applied_at TIMESTAMP DEFAULT NOW()
      )
    `);
  },
  down: async (db: any) => {
    await db.execute(`DROP TABLE IF EXISTS migration_history;`);
  },
};
Handling Complex Migrations

Adding Columns with Default Values

typescript
Copy code
// FILE: src/migrations/3_add_status_to_users.ts
export default {
  name: "3_add_status_to_users",
  up: async (db: any) => {
    await db.execute(`ALTER TABLE users ADD COLUMN status VARCHAR(50) DEFAULT 'active';`);
  },
  down: async (db: any) => {
    await db.execute(`ALTER TABLE users DROP COLUMN IF EXISTS status;`);
  },
};
Renaming Tables or Columns

typescript
Copy code
// FILE: src/migrations/4_rename_users_to_members.ts
export default {
  name: "4_rename_users_to_members",
  up: async (db: any) => {
    await db.execute(`ALTER TABLE users RENAME TO members;`);
  },
  down: async (db: any) => {
    await db.execute(`ALTER TABLE members RENAME TO users;`);
  },
};
Automating Migration Discovery

Instead of manually importing migration files, automate their discovery based on a naming convention.
typescript
Copy code
// FILE: src/migrations/MigrationRunner.ts (Updated)
import { DatabaseAdapter } from "../adapters/interfaces/DatabaseAdapter.ts";
import { MigrationError } from "./MigrationRunner.ts";
import { join, extname } from "https://deno.land/std@0.190.0/path/mod.ts";

export class MigrationRunner {
  private migrationTable = "migration_history";

  constructor(private adapter: DatabaseAdapter, private migrationsDir: string) {}

  async initializeMigrationTable() {
    const createTableQuery = `
      CREATE TABLE IF NOT EXISTS ${this.migrationTable} (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL UNIQUE,
        applied_at TIMESTAMP DEFAULT NOW()
      )
    `;
    await this.adapter.execute(createTableQuery);
  }

  async getAppliedMigrations(): Promise<Set<string>> {
    const rows = await this.adapter.execute(`SELECT name FROM ${this.migrationTable}`);
    return new Set(rows.map((row: any) => row.name));
  }

  async loadMigrations(): Promise<any[]> {
    const migrations: any[] = [];
    for await (const dirEntry of Deno.readDir(this.migrationsDir)) {
      if (dirEntry.isFile && extname(dirEntry.name) === ".ts") {
        const migration = await import(join(this.migrationsDir, dirEntry.name));
        migrations.push(migration.default);
      }
    }
    // Sort migrations based on name to ensure order
    migrations.sort((a, b) => a.name.localeCompare(b.name));
    return migrations;
  }

  async applyMigrations() {
    await this.initializeMigrationTable();
    const applied = await this.getAppliedMigrations();
    const migrations = await this.loadMigrations();

    for (const migration of migrations) {
      if (!applied.has(migration.name)) {
        await this.adapter.beginTransaction();
        try {
          await migration.up(this.adapter);
          await this.adapter.execute(`INSERT INTO ${this.migrationTable} (name) VALUES ($1)`, [migration.name]);
          await this.adapter.commitTransaction();
          console.log(`Applied migration: ${migration.name}`);
        } catch (err) {
          await this.adapter.rollbackTransaction();
          throw new MigrationError(`Failed to apply migration ${migration.name}: ${err.message}`);
        }
      }
    }
  }

  async rollbackLastMigration() {
    await this.initializeMigrationTable();
    const rows = await this.adapter.execute(`SELECT name FROM ${this.migrationTable} ORDER BY applied_at DESC LIMIT 1`);
    if (rows.length === 0) {
      console.log("No migrations to rollback.");
      return;
    }
    const lastMigrationName = rows[0].name;
    const migrations = await this.loadMigrations();
    const migration = migrations.find(m => m.name === lastMigrationName);
    if (!migration) {
      throw new MigrationError(`Migration file for ${lastMigrationName} not found.`);
    }

    await this.adapter.beginTransaction();
    try {
      await migration.down(this.adapter);
      await this.adapter.execute(`DELETE FROM ${this.migrationTable} WHERE name = $1`, [migration.name]);
      await this.adapter.commitTransaction();
      console.log(`Rolled back migration: ${migration.name}`);
    } catch (err) {
      await this.adapter.rollbackTransaction();
      throw new MigrationError(`Failed to rollback migration ${migration.name}: ${err.message}`);
    }
  }
}
==== Plugin System
Example:

A caching plugin that intercepts reads and writes, storing frequently requested rows.
A specialized logging plugin that outputs queries to a file or external service.
Plugin Registration:

typescript
Copy code
// FILE: src/plugins/PluginSystem.ts
export interface ORMPlugin {
  name: string;
  initialize(): void;
  beforeQuery?(query: string, params: any[]): void;
  afterQuery?(query: string, params: any[], result: any): void;
}

export class PluginSystem {
  private static _plugins: ORMPlugin[] = [];

  static registerPlugin(plugin: ORMPlugin) {
    this._plugins.push(plugin);
    plugin.initialize();
  }

  static getPlugins(): ORMPlugin[] {
    return this._plugins;
  }

  static async executeBeforeQuery(query: string, params: any[]): Promise<void> {
    for (const plugin of this._plugins) {
      if (plugin.beforeQuery) {
        await plugin.beforeQuery(query, params);
      }
    }
  }

  static async executeAfterQuery(query: string, params: any[], result: any): Promise<void> {
    for (const plugin of this._plugins) {
      if (plugin.afterQuery) {
        await plugin.afterQuery(query, params, result);
      }
    }
  }
}
Example Logging Plugin:

typescript
Copy code
// FILE: src/plugins/LoggingPlugin.ts
import { ORMPlugin } from "./PluginSystem.ts";

export class LoggingPlugin implements ORMPlugin {
  name = "LoggingPlugin";

  initialize() {
    console.log("LoggingPlugin initialized.");
  }

  beforeQuery(query: string, params: any[]) {
    console.debug(`Executing Query: ${query} with params: ${JSON.stringify(params)}`);
  }

  afterQuery(query: string, params: any[], result: any) {
    console.debug(`Query Result: ${JSON.stringify(result)}`);
  }
}
Integrating Plugins with Query Execution:

typescript
Copy code
// FILE: src/adapters/PostgresAdapter.ts (Updated)
import { PostgresClient, PostgresPool } from "../../deps.ts";
import { DatabaseAdapter } from "./interfaces/DatabaseAdapter.ts";
import { PluginSystem } from "../plugins/PluginSystem.ts";

export class PostgresAdapter implements DatabaseAdapter {
  private pool: PostgresPool | null = null;

  constructor(private config: PostgresConfig) {}

  // ... existing methods

  async execute(query: string, params: any[] = []): Promise<any> {
    if (!this.pool) {
      throw new Error("PostgresAdapter not connected.");
    }

    // Execute beforeQuery plugins
    await PluginSystem.executeBeforeQuery(query, params);

    const client = await this.pool.connect();
    try {
      const result = await client.queryArray(query, ...params);

      // Execute afterQuery plugins
      await PluginSystem.executeAfterQuery(query, params, result.rows);

      return result.rows;
    } finally {
      client.release();
    }
  }

  // ... existing methods
}
==== CLI Tool
Goals:

Provide convenience for tasks like migrations, model generation, debugging queries.
Potentially read a configuration file (e.g., rex-orm.config.json).
Sample:

typescript
Copy code
// FILE: cli.ts
import { DatabaseFactory } from "./src/adapters/DatabaseFactory.ts";
import { MigrationRunner } from "./src/migrations/MigrationRunner.ts";
import { LoggingPlugin } from "./src/plugins/LoggingPlugin.ts";
import { PluginSystem } from "./src/plugins/PluginSystem.ts";

import { exists } from "https://deno.land/std@0.190.0/fs/mod.ts";

if (import.meta.main) {
  const [command, ...args] = Deno.args;

  // Load configuration from rex-orm.config.json
  const configPath = "./rex-orm.config.json";
  if (!await exists(configPath)) {
    console.error(`Configuration file ${configPath} not found.`);
    Deno.exit(1);
  }

  const config = await import(`./${configPath}`);

  // Initialize Database Adapter
  const adapter = DatabaseFactory.createAdapter(config.default.database);

  // Register Plugins
  PluginSystem.registerPlugin(new LoggingPlugin());
  // Register other plugins as needed

  const runner = new MigrationRunner(adapter, config.default.migrationsDir || "./src/migrations");

  switch (command) {
    case "migrate":
      await adapter.connect();
      await runner.applyMigrations();
      await adapter.disconnect();
      console.log("Migrations applied successfully.");
      break;

    case "rollback":
      await adapter.connect();
      await runner.rollbackLastMigration();
      await adapter.disconnect();
      console.log("Migration rolled back successfully.");
      break;

    case "generate:model":
      const modelName = args[0];
      if (!modelName) {
        console.error("Model name is required.");
        Deno.exit(1);
      }
      // Implement model scaffolding logic
      await generateModel(modelName);
      console.log(`Model ${modelName} generated successfully.`);
      break;

    case "help":
    default:
      console.log(`Unknown command: ${command}`);
      console.log("Available commands: migrate, rollback, generate:model, help");
      break;
  }
}

// Example Model Generator Function
async function generateModel(name: string) {
  const modelsDir = "./src/models/";
  const filePath = `${modelsDir}${name}.ts`;
  const template = `import { Entity, PrimaryKey, Column } from "./decorators.ts";
@Entity("${name.toLowerCase()}s") export class ${name} { @PrimaryKey() id!: number;

@Column({ type: "varchar", length: 255, nullable: false }) name!: string;

// Add additional columns as needed } `; await Deno.writeTextFile(filePath, template); }

arduino
Copy code

- **Configuration File Example (`rex-orm.config.json`)**:
```json
{
  "database": {
    "type": "postgres",
    "host": "localhost",
    "user": "admin",
    "password": "password",
    "port": 5432,
    "database": "rexorm_db",
    "poolSize": 10
  },
  "migrationsDir": "./src/migrations",
  "plugins": [
    "./src/plugins/LoggingPlugin.ts"
  ]
}
Extended CLI Features:
Generating Migrations:
typescript
Copy code
// Extend cli.ts with generate:migration command
case "generate:migration":
  const migrationName = args[0];
  if (!migrationName) {
    console.error("Migration name is required.");
    Deno.exit(1);
  }
  await generateMigration(migrationName, runner.migrationsDir);
  console.log(`Migration ${migrationName} generated successfully.`);
  break;

// Example Migration Generator Function
async function generateMigration(name: string, migrationsDir: string) {
  const timestamp = Date.now();
  const fileName = `${timestamp}_${name}.ts`;
  const filePath = `${migrationsDir}/${fileName}`;
  const template = `export default {
name: "${timestamp}_${name}", up: async (db: any) => { // Implement migration logic here }, down: async (db: any) => { // Implement rollback logic here }, }; `; await Deno.writeTextFile(filePath, template); }
arduino
Copy code

- **Adding Help and Usage Instructions**:
```typescript
// Update the help case in cli.ts
case "help":
  console.log(`
Rex-ORM CLI

Commands: migrate Apply all pending migrations. rollback Rollback the last applied migration. generate:model <Name> Generate a new model file. generate:migration <Name> Generate a new migration file. help Show this help message.

Examples: deno run cli.ts migrate deno run cli.ts rollback deno run cli.ts generate:model User deno run cli.ts generate:migration add_email_to_users `); break; ```

==== Validation System
Comprehensive Validation Decorators:

typescript
Copy code
// FILE: src/models/validation.ts (Extended)
export function IsEmail() {
  return function (target: any, propertyKey: string) {
    Reflect.defineMetadata(`validate:${propertyKey}`, "email", target.constructor);
  };
}

export function IsNumeric() {
  return function (target: any, propertyKey: string) {
    Reflect.defineMetadata(`validate:${propertyKey}`, "numeric", target.constructor);
  };
}

export function Length(min: number, max: number) {
  return function (target: any, propertyKey: string) {
    Reflect.defineMetadata(`validate:${propertyKey}`, { min, max }, target.constructor);
  };
}

export function IsOptional() {
  return function (target: any, propertyKey: string) {
    Reflect.defineMetadata(`validate:${propertyKey}`, "optional", target.constructor);
  };
}

// Additional validators can be added similarly
Integrating Validation into Repository:

typescript
Copy code
// FILE: src/models/Repository.ts (Updated)
import { DatabaseAdapter } from "../adapters/interfaces/DatabaseAdapter.ts";
import "https://deno.land/x/reflect_metadata@v0.1.12/mod.ts";
import { ValidationError } from "../errors/ValidationError.ts";

export class Repository<T> {
  constructor(private adapter: DatabaseAdapter, private model: { new (): T }) {}

  async save(entity: T): Promise<void> {
    // Validate entity
    const prototype = this.model.prototype;
    const columns: any[] = Reflect.getMetadata("columns", this.model) || [];
    for (const column of columns) {
      const { propertyKey, options } = column;
      const value = (entity as any)[propertyKey];
      const validation = Reflect.getMetadata(`validate:${propertyKey}`, this.model);

      if (validation) {
        if (validation === "email") {
          if (!validateEmail(value)) {
            throw new ValidationError(`Invalid email format for ${propertyKey}`);
          }
        } else if (validation === "numeric") {
          if (typeof value !== "number") {
            throw new ValidationError(`${propertyKey} must be a number.`);
          }
        } else if (typeof validation === "object") {
          const { min, max } = validation;
          if (value.length < min || value.length > max) {
            throw new ValidationError(`Length of ${propertyKey} must be between ${min} and ${max}`);
          }
        } else if (validation === "optional") {
          // Handle optional fields if needed
        }
        // Additional validations can be handled here
      }

      // Check for non-nullable constraints
      if (!options.nullable && (value === null || value === undefined)) {
        throw new ValidationError(`${propertyKey} cannot be null or undefined.`);
      }
    }

    // Proceed with saving (Insert or Update)
    // ...
  }

  // Additional CRUD methods with validation
}

function validateEmail(email: string): boolean {
  const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return re.test(email);
}
Custom Validation Rules:

Allow developers to define custom validation logic.

typescript
Copy code
// FILE: src/models/validation.ts (Extended)
export function CustomValidator(validatorFn: (value: any) => boolean, message: string) {
  return function (target: any, propertyKey: string) {
    Reflect.defineMetadata(`validate:${propertyKey}`, { validatorFn, message }, target.constructor);
  };
}
Usage Example:
typescript
Copy code
// FILE: src/models/User.ts
import { Entity, PrimaryKey, Column } from "./decorators.ts";
import { OneToMany } from "./relationships.ts";
import { Post } from "./Post.ts";
import { CustomValidator } from "./validation.ts";

@Entity("users")
export class User {
  @PrimaryKey()
  id!: number;

  @Column({ type: "varchar", length: 255, nullable: false })
  name!: string;

  @Column({ type: "varchar", length: 255, unique: true, nullable: false })
  @IsEmail()
  email!: string;

  @CustomValidator(
    (value: string) => value.startsWith("USR"),
    "User ID must start with 'USR'"
  )
  @Column({ type: "varchar", length: 10, nullable: false })
  userId!: string;

  @OneToMany(() => Post, "user")
  posts?: Post[];
}
==== Logging Enhancements
Configurable Logging Levels and Backends

Allow users to configure logging levels and choose logging backends (console, file, external services).
typescript
Copy code
// FILE: src/plugins/LoggingPlugin.ts (Extended)
import { ORMPlugin } from "./PluginSystem.ts";

type LogLevel = "debug" | "info" | "warn" | "error";

interface LoggingPluginOptions {
  level: LogLevel;
  backend: "console" | "file" | "external";
  filePath?: string; // Required if backend is file
  externalServiceUrl?: string; // Required if backend is external
}

export class LoggingPlugin implements ORMPlugin {
  name = "LoggingPlugin";
  private options: LoggingPluginOptions;

  constructor(options: LoggingPluginOptions) {
    this.options = options;
  }

  initialize() {
    console.log(`LoggingPlugin initialized with level: ${this.options.level}`);
  }

  beforeQuery(query: string, params: any[]) {
    if (this.shouldLog("debug")) {
      this.log("debug", `Executing Query: ${query} with params: ${JSON.stringify(params)}`);
    }
  }

  afterQuery(query: string, params: any[], result: any) {
    if (this.shouldLog("info")) {
      this.log("info", `Query Result: ${JSON.stringify(result)}`);
    }
  }

  private shouldLog(level: LogLevel): boolean {
    const levels: Record<LogLevel, number> = {
      "debug": 1,
      "info": 2,
      "warn": 3,
      "error": 4,
    };
    return levels[level] >= levels[this.options.level];
  }

  private async log(level: LogLevel, message: string) {
    switch (this.options.backend) {
      case "console":
        console[level](message);
        break;
      case "file":
        if (this.options.filePath) {
          await Deno.writeTextFile(this.options.filePath, `[${level.toUpperCase()}] ${message}\n`, { append: true });
        }
        break;
      case "external":
        if (this.options.externalServiceUrl) {
          // Send log to external service
          await fetch(this.options.externalServiceUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ level, message, timestamp: new Date().toISOString() }),
          });
        }
        break;
    }
  }
}
Registering the Enhanced Logging Plugin via CLI

typescript
Copy code
// FILE: cli.ts (Updated)
import { LoggingPlugin } from "./src/plugins/LoggingPlugin.ts";

// ... existing imports and code

if (import.meta.main) {
  const [command, ...args] = Deno.args;

  // Load configuration from rex-orm.config.json
  const configPath = "./rex-orm.config.json";
  if (!await exists(configPath)) {
    console.error(`Configuration file ${configPath} not found.`);
    Deno.exit(1);
  }

  const config = await import(`./${configPath}`);

  // Initialize Database Adapter
  const adapter = DatabaseFactory.createAdapter(config.default.database);

  // Register Plugins with options
  PluginSystem.registerPlugin(new LoggingPlugin({
    level: "debug",
    backend: "console",
    // filePath: "./logs/rexorm.log",
    // externalServiceUrl: "https://logging-service.example.com/logs",
  }));
  // Register other plugins as needed

  const runner = new MigrationRunner(adapter, config.default.migrationsDir || "./src/migrations");

  // ... existing switch case
}
==== Advanced Relationship Handling
Eager and Lazy Loading

Eager Loading: Automatically fetch related entities when querying a primary entity.

typescript
Copy code
// FILE: src/models/Repository.ts (Extended)
export class Repository<T> {
  // ... existing constructor and methods

  async findOne(id: number, options?: { relations?: string[] }): Promise<T | null> {
    const query = new QueryBuilder()
      .select('*')
      .from(this.getTableName())
      .where('id', '=', id);

    const result = await query.execute(this.adapter);
    if (result.length === 0) return null;

    const entity = new this.model();
    Object.assign(entity, result[0]);

    if (options?.relations) {
      for (const relation of options.relations) {
        const relatedData = await this.loadRelation(entity, relation);
        (entity as any)[relation] = relatedData;
      }
    }

    return entity;
  }

  private async loadRelation(entity: T, relation: string): Promise<any> {
    const metadata = Reflect.getMetadata("relationships", this.model) || [];
    const relationMeta = metadata.find((r: any) => r.propertyKey === relation);
    if (!relationMeta) throw new Error(`Relation ${relation} not defined on model.`);

    const relatedAdapter = this.getRelatedAdapter(relationMeta.relatedClass);
    const relatedRepository = new Repository(relatedAdapter, relationMeta.relatedClass);

    switch (relationMeta.type) {
      case "OneToMany":
        return await relatedRepository.findMany({ [relationMeta.mappedBy]: (entity as any).id });
      case "ManyToOne":
        return await relatedRepository.findOne((entity as any)[`${relation}_id`]);
      // Handle other relation types
      default:
        throw new Error(`Relation type ${relationMeta.type} not supported.`);
    }
  }

  private getRelatedAdapter(relatedClass: any): DatabaseAdapter {
    // Logic to determine and return the appropriate adapter for the related class
    // This can be enhanced based on project requirements
    return this.adapter;
  }

  async findMany(criteria?: Partial<T>, options?: { relations?: string[] }): Promise<T[]> {
    const query = new QueryBuilder().select('*').from(this.getTableName());

    if (criteria) {
      for (const [key, value] of Object.entries(criteria)) {
        query.where(key, '=', value);
      }
    }

    const results = await query.execute(this.adapter);
    const entities: T[] = [];

    for (const row of results) {
      const entity = new this.model();
      Object.assign(entity, row);

      if (options?.relations) {
        for (const relation of options.relations) {
          const relatedData = await this.loadRelation(entity, relation);
          (entity as any)[relation] = relatedData;
        }
      }

      entities.push(entity);
    }

    return entities;
  }

  private getTableName(): string {
    const tableName = Reflect.getMetadata("tableName", this.model);
    if (!tableName) throw new Error("Model does not have a table name defined.");
    return tableName;
  }
}
Lazy Loading: Fetch related entities only when they are accessed.

typescript
Copy code
// FILE: src/models/User.ts (Updated)
import { Entity, PrimaryKey, Column } from "./decorators.ts";
import { OneToMany } from "./relationships.ts";
import { Post } from "./Post.ts";
import { Repository } from "./Repository.ts";
import { DatabaseAdapter } from "../adapters/interfaces/DatabaseAdapter.ts";

@Entity("users")
export class User {
  @PrimaryKey()
  id!: number;

  @Column({ type: "varchar", length: 255, nullable: false })
  name!: string;

  @Column({ type: "varchar", length: 255, unique: true, nullable: false })
  email!: string;

  @OneToMany(() => Post, "user")
  posts?: Post[];

  // Lazy loaded getter
  private _postsRepository?: Repository<Post>;

  async getPosts(adapter: DatabaseAdapter): Promise<Post[]> {
    if (!this._postsRepository) {
      this._postsRepository = new Repository(adapter, Post);
    }
    return await this._postsRepository.findMany({ user_id: this.id });
  }
}
Handling Many-to-Many Relationships

Defining Many-to-Many Relationships with Join Tables:

typescript
Copy code
// FILE: src/models/Student.ts
import { Entity, PrimaryKey, Column } from "./decorators.ts";
import { ManyToMany } from "./relationships.ts";
import { Course } from "./Course.ts";

@Entity("students")
export class Student {
  @PrimaryKey()
  id!: number;

  @Column({ type: "varchar", length: 255, nullable: false })
  name!: string;

  @ManyToMany(() => Course, "student_courses")
  courses?: Course[];
}
typescript
Copy code
// FILE: src/models/Course.ts
import { Entity, PrimaryKey, Column } from "./decorators.ts";
import { ManyToMany } from "./relationships.ts";
import { Student } from "./Student.ts";

@Entity("courses")
export class Course {
  @PrimaryKey()
  id!: number;

  @Column({ type: "varchar", length: 255, nullable: false })
  title!: string;

  @ManyToMany(() => Student, "student_courses")
  students?: Student[];
}
Join Table Migration:

typescript
Copy code
// FILE: src/migrations/5_create_student_courses_table.ts
export default {
  name: "5_create_student_courses_table",
  up: async (db: any) => {
    await db.execute(`
      CREATE TABLE IF NOT EXISTS student_courses (
        student_id INTEGER REFERENCES students(id) ON DELETE CASCADE,
        course_id INTEGER REFERENCES courses(id) ON DELETE CASCADE,
        PRIMARY KEY (student_id, course_id)
      )
    `);
  },
  down: async (db: any) => {
    await db.execute(`DROP TABLE IF EXISTS student_courses;`);
  },
};
Handling Many-to-Many Operations in Repository:

typescript
Copy code
// FILE: src/models/Repository.ts (Extended for Many-to-Many)
export class Repository<T> {
  // ... existing methods

  async addRelation(entity: T, relation: string, relatedEntityId: number): Promise<void> {
    const metadata = Reflect.getMetadata("relationships", this.model) || [];
    const relationMeta = metadata.find((r: any) => r.propertyKey === relation);
    if (!relationMeta || relationMeta.type !== "ManyToMany") {
      throw new Error(`Relation ${relation} is not a ManyToMany relation on this model.`);
    }

    const joinTable = relationMeta.joinTable || `${this.getTableName()}_${relationMeta.relatedClass.name.toLowerCase()}s`;
    const entityId = (entity as any).id;
    const relatedColumn = `${relationMeta.relatedClass.name.toLowerCase()}_id`;

    const query = `
      INSERT INTO ${joinTable} (${this.getTableName().slice(0, -1)}_id, ${relatedColumn})
      VALUES ($1, $2)
      ON CONFLICT DO NOTHING
    `;
    await this.adapter.execute(query, [entityId, relatedEntityId]);
  }

  async removeRelation(entity: T, relation: string, relatedEntityId: number): Promise<void> {
    const metadata = Reflect.getMetadata("relationships", this.model) || [];
    const relationMeta = metadata.find((r: any) => r.propertyKey === relation);
    if (!relationMeta || relationMeta.type !== "ManyToMany") {
      throw new Error(`Relation ${relation} is not a ManyToMany relation on this model.`);
    }

    const joinTable = relationMeta.joinTable || `${this.getTableName()}_${relationMeta.relatedClass.name.toLowerCase()}s`;
    const entityId = (entity as any).id;
    const relatedColumn = `${relationMeta.relatedClass.name.toLowerCase()}_id`;

    const query = `
      DELETE FROM ${joinTable}
      WHERE ${this.getTableName().slice(0, -1)}_id = $1 AND ${relatedColumn} = $2
    `;
    await this.adapter.execute(query, [entityId, relatedEntityId]);
  }

  async getRelations(entity: T, relation: string): Promise<any[]> {
    const metadata = Reflect.getMetadata("relationships", this.model) || [];
    const relationMeta = metadata.find((r: any) => r.propertyKey === relation);
    if (!relationMeta || relationMeta.type !== "ManyToMany") {
      throw new Error(`Relation ${relation} is not a ManyToMany relation on this model.`);
    }

    const joinTable = relationMeta.joinTable || `${this.getTableName()}_${relationMeta.relatedClass.name.toLowerCase()}s`;
    const relatedTable = relationMeta.relatedClass.prototype.constructor.name.toLowerCase() + "s";
    const relatedColumn = `${relationMeta.relatedClass.name.toLowerCase()}_id`;

    const query = `
      SELECT ${relatedTable}.* FROM ${relatedTable}
      INNER JOIN ${joinTable} ON ${relatedTable}.id = ${joinTable}.${relatedColumn}
      WHERE ${joinTable}.${this.getTableName().slice(0, -1)}_id = $1
    `;
    const rows = await this.adapter.execute(query, [(entity as any).id]);
    return rows;
  }
}
Self-Referential Relationships

Example: Employee Manager Relationship

typescript
Copy code
// FILE: src/models/Employee.ts
import { Entity, PrimaryKey, Column } from "./decorators.ts";
import { ManyToOne, OneToMany } from "./relationships.ts";

@Entity("employees")
export class Employee {
  @PrimaryKey()
  id!: number;

  @Column({ type: "varchar", length: 255, nullable: false })
  name!: string;

  @ManyToOne(() => Employee, "subordinates")
  manager?: Employee;

  @OneToMany(() => Employee, "manager")
  subordinates?: Employee[];
}
Migration for Self-Referential Foreign Key

typescript
Copy code
// FILE: src/migrations/6_create_employees_table.ts
export default {
  name: "6_create_employees_table",
  up: async (db: any) => {
    await db.execute(`
      CREATE TABLE IF NOT EXISTS employees (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        manager_id INTEGER REFERENCES employees(id) ON DELETE SET NULL
      )
    `);
  },
  down: async (db: any) => {
    await db.execute(`DROP TABLE IF EXISTS employees;`);
  },
};
==== Transaction Management
Basic Transaction Handling

As previously shown, using beginTransaction, commitTransaction, and rollbackTransaction methods.
Advanced Transaction Patterns

Nested Transactions with Savepoints

typescript
Copy code
// FILE: src/adapters/interfaces/DatabaseAdapter.ts (Extended)
export interface DatabaseAdapter {
  // ... existing methods
  savepoint(name: string): Promise<void>;
  releaseSavepoint(name: string): Promise<void>;
  rollbackToSavepoint(name: string): Promise<void>;
}
Using Nested Transactions

typescript
Copy code
// Usage Example
await adapter.beginTransaction();
try {
  await adapter.execute("INSERT INTO users (name, email) VALUES ($1, $2)", ["Alice", "alice@example.com"]);

  await adapter.savepoint("sp1");
  try {
    await adapter.execute("INSERT INTO posts (title, content, user_id) VALUES ($1, $2, $3)", ["Post Title", "Post Content", 1]);
  } catch (err) {
    await adapter.rollbackToSavepoint("sp1");
    console.warn("Failed to insert post, rolled back to savepoint sp1.");
  }

  await adapter.commitTransaction();
} catch (err) {
  await adapter.rollbackTransaction();
  throw err;
}
Handling Distributed Transactions

Note: Distributed transactions across multiple databases or services are complex and typically require a transaction coordinator or a two-phase commit protocol. Rex-ORM can provide interfaces or hooks to integrate with such systems, but the implementation is beyond the scope of this guide.
==== Extended Design Patterns
Factory Pattern

Purpose: For adapter instantiation based on config.
typescript
Copy code
// FILE: src/adapters/DatabaseFactory.ts
import { DatabaseAdapter } from "./interfaces/DatabaseAdapter.ts";
import { PostgresAdapter } from "./PostgresAdapter.ts";
import { SQLiteAdapter } from "./SQLiteAdapter.ts";

export class DatabaseFactory {
  static createAdapter(config: any): DatabaseAdapter {
    if (config.type === "postgres") {
      return new PostgresAdapter(config);
    } else if (config.type === "sqlite") {
      return new SQLiteAdapter(config);
    } else {
      throw new Error(`Unsupported database type: ${config.type}`);
    }
  }
}
Decorator Pattern

Purpose: For easy model definitions (@Entity, @Column).
Purpose: For relationships (@OneToMany, etc.).
Chain of Responsibility

Purpose: Could be used to process queries in stages (cache -> transform -> logging -> execute).

Implementation Example:

typescript
Copy code
// FILE: src/query/handlers/CacheHandler.ts
import { QueryHandler } from "./QueryHandler.ts";
import { CachePlugin } from "../../plugins/CachePlugin.ts";

export class CacheHandler extends QueryHandler {
  constructor(private cache: CachePlugin) {
    super();
  }

  async handle(query: string, params: any[]): Promise<any> {
    const cacheKey = this.cache.generateKey(query, params);
    const cachedResult = this.cache.get(cacheKey);
    if (cachedResult) {
      return cachedResult;
    }
    const result = await this.next?.handle(query, params);
    this.cache.set(cacheKey, result);
    return result;
  }
}
typescript
Copy code
// FILE: src/query/handlers/LoggingHandler.ts
import { QueryHandler } from "./QueryHandler.ts";

export class LoggingHandler extends QueryHandler {
  async handle(query: string, params: any[]): Promise<any> {
    console.log(`Executing Query: ${query} with params: ${JSON.stringify(params)}`);
    const result = await this.next?.handle(query, params);
    console.log(`Query Result: ${JSON.stringify(result)}`);
    return result;
  }
}
typescript
Copy code
// FILE: src/query/handlers/FinalHandler.ts
import { QueryHandler } from "./QueryHandler.ts";
import { DatabaseAdapter } from "../../adapters/interfaces/DatabaseAdapter.ts";

export class FinalHandler extends QueryHandler {
  constructor(private adapter: DatabaseAdapter) {
    super();
  }

  async handle(query: string, params: any[]): Promise<any> {
    return await this.adapter.execute(query, params);
  }
}
typescript
Copy code
// FILE: src/query/handlers/QueryHandler.ts
export abstract class QueryHandler {
  protected next?: QueryHandler;

  setNext(handler: QueryHandler): QueryHandler {
    this.next = handler;
    return handler;
  }

  abstract handle(query: string, params: any[]): Promise<any>;
}
Using the Chain of Responsibility
typescript
Copy code
// FILE: src/query/QueryExecutor.ts
import { QueryHandler } from "./handlers/QueryHandler.ts";
import { CacheHandler } from "./handlers/CacheHandler.ts";
import { LoggingHandler } from "./handlers/LoggingHandler.ts";
import { FinalHandler } from "./handlers/FinalHandler.ts";
import { DatabaseAdapter } from "../adapters/interfaces/DatabaseAdapter.ts";
import { CachePlugin } from "../plugins/CachePlugin.ts";

export class QueryExecutor {
  private handlerChain: QueryHandler;

  constructor(private adapter: DatabaseAdapter, private cache: CachePlugin) {
    const cacheHandler = new CacheHandler(cache);
    const loggingHandler = new LoggingHandler();
    const finalHandler = new FinalHandler(adapter);

    cacheHandler.setNext(loggingHandler).setNext(finalHandler);
    this.handlerChain = cacheHandler;
  }

  async execute(query: string, params: any[]): Promise<any> {
    return await this.handlerChain.handle(query, params);
  }
}
Observer Pattern

Purpose: Could be used for lifecycle hooks (e.g. beforeSave, afterSave).
typescript
Copy code
// FILE: src/events/Event.ts
export interface Event {
  name: string;
  data: any;
}

// FILE: src/events/EventEmitter.ts
export class EventEmitter {
  private events: Record<string, Array<(data: any) => void>> = {};

  on(eventName: string, listener: (data: any) => void) {
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }
    this.events[eventName].push(listener);
  }

  emit(event: Event) {
    const listeners = this.events[event.name];
    if (listeners) {
      listeners.forEach(listener => listener(event.data));
    }
  }
}
Integrating EventEmitter into Repository
typescript
Copy code
// FILE: src/models/Repository.ts (Extended with Events)
import { EventEmitter } from "../events/EventEmitter.ts";

export class Repository<T> {
  private eventEmitter = new EventEmitter();

  constructor(private adapter: DatabaseAdapter, private model: { new (): T }) {}

  on(eventName: string, listener: (data: any) => void) {
    this.eventEmitter.on(eventName, listener);
  }

  async save(entity: T): Promise<void> {
    this.eventEmitter.emit({ name: "beforeSave", data: entity });

    // Validate and save entity
    // ...

    this.eventEmitter.emit({ name: "afterSave", data: entity });
  }

  // Additional CRUD methods with event emissions
}
Repository Pattern

Purpose: Create specific classes for domain logic if the codebase grows large.
typescript
Copy code
// FILE: src/repositories/UserRepository.ts
import { Repository } from "../models/Repository.ts";
import { User } from "../models/User.ts";
import { DatabaseAdapter } from "../adapters/interfaces/DatabaseAdapter.ts";

export class UserRepository extends Repository<User> {
  constructor(adapter: DatabaseAdapter) {
    super(adapter, User);
  }

  async findByEmail(email: string): Promise<User | null> {
    const query = new QueryBuilder()
      .select('*')
      .from(this.getTableName())
      .where('email', '=', email);
    const results = await query.execute(this.adapter);
    if (results.length === 0) return null;
    const user = new User();
    Object.assign(user, results[0]);
    return user;
  }

  // Additional user-specific methods
}
==== Security Considerations
Parameterized Queries

Always use parameterized queries to prevent SQL injection.
Example:
typescript
Copy code
const query = "SELECT * FROM users WHERE email = $1";
const params = ["user@example.com"];
const result = await adapter.execute(query, params);
Secure Credential Management

Use environment variables to manage database credentials.

Example with deno.env:

typescript
Copy code
// FILE: src/config.ts
export const config = {
  database: {
    type: Deno.env.get("DB_TYPE") || "postgres",
    host: Deno.env.get("DB_HOST") || "localhost",
    user: Deno.env.get("DB_USER") || "admin",
    password: Deno.env.get("DB_PASSWORD") || "password",
    port: Number(Deno.env.get("DB_PORT")) || 5432,
    database: Deno.env.get("DB_NAME") || "rexorm_db",
    poolSize: Number(Deno.env.get("DB_POOL_SIZE")) || 10,
  },
  // ... other configurations
};
Loading Environment Variables Securely:

Use .env files and load them at runtime.
Example:
typescript
Copy code
// FILE: src/loadEnv.ts
import { config as loadConfig } from "https://deno.land/std@0.190.0/dotenv/mod.ts";

const env = await loadConfig({ export: true });
Input Validation

Validate all inputs before performing database operations to ensure data integrity and security.
Role-Based Access Control (RBAC)

Implement role-based access controls within the ORM to restrict certain operations based on user roles.
typescript
Copy code
// FILE: src/security/RBAC.ts
export type Role = "admin" | "user" | "guest";

export class RBAC {
  private permissions: Record<Role, string[]> = {
    admin: ["create", "read", "update", "delete"],
    user: ["read", "update"],
    guest: ["read"],
  };

  can(role: Role, action: string): boolean {
    return this.permissions[role].includes(action);
  }
}
Integrating RBAC with Repository Operations
typescript
Copy code
// FILE: src/models/Repository.ts (Extended with RBAC)
import { RBAC, Role } from "../security/RBAC.ts";

export class Repository<T> {
  private rbac = new RBAC();

  constructor(private adapter: DatabaseAdapter, private model: { new (): T }) {}

  async delete(entity: T, role: Role): Promise<void> {
    if (!this.rbac.can(role, "delete")) {
      throw new AuthorizationError("You do not have permission to delete this entity.");
    }
    // Proceed with delete operation
    // ...
  }

  // Other methods with RBAC checks
}

// Custom Error
export class AuthorizationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "AuthorizationError";
  }
}
==== Performance Optimizations
Indexing

Create indexes on frequently queried columns to speed up read operations.
Example Migration:
typescript
Copy code
// FILE: src/migrations/7_create_email_index.ts
export default {
  name: "7_create_email_index",
  up: async (db: any) => {
    await db.execute(`CREATE INDEX idx_users_email ON users(email);`);
  },
  down: async (db: any) => {
    await db.execute(`DROP INDEX IF EXISTS idx_users_email;`);
  },
};
Batch Operations

Execute multiple inserts or updates in a single query to reduce round-trips.
typescript
Copy code
// FILE: src/models/Repository.ts (Extended with Batch Insert)
export class Repository<T> {
  // ... existing methods

  async batchInsert(entities: T[]): Promise<void> {
    if (entities.length === 0) return;

    const columns = Reflect.getMetadata("columns", this.model) || [];
    const columnNames = columns.map(col => col.propertyKey);
    const placeholders = entities.map((_, i) => `(${columnNames.map((_, j) => `$${i * columnNames.length + j + 1}`).join(", ")})`).join(", ");
    const flatParams = entities.flatMap(entity => columnNames.map(col => (entity as any)[col]));

    const query = `INSERT INTO ${this.getTableName()} (${columnNames.join(", ")}) VALUES ${placeholders}`;
    await this.adapter.execute(query, flatParams);
  }
}
Connection Pool Tuning

Adjust pool size based on application load and database capabilities to optimize resource utilization.
typescript
Copy code
// FILE: rex-orm.config.json (Example)
{
  "database": {
    "type": "postgres",
    "host": "localhost",
    "user": "admin",
    "password": "password",
    "port": 5432,
    "database": "rexorm_db",
    "poolSize": 20
  },
  // ... other configurations
}
Caching Frequently Accessed Data

Utilize the caching system to store results of expensive or frequently run queries.
typescript
Copy code
// FILE: src/plugins/CachePlugin.ts
import { ORMPlugin } from "./PluginSystem.ts";

export class CachePlugin implements ORMPlugin {
  name = "CachePlugin";
  private cache: Map<string, any> = new Map();

  initialize() {
    console.log("CachePlugin initialized.");
  }

  generateKey(query: string, params: any[]): string {
    return `${query}|${JSON.stringify(params)}`;
  }

  get(key: string): any | undefined {
    return this.cache.get(key);
  }

  set(key: string, value: any): void {
    this.cache.set(key, value);
  }

  invalidate(key: string): void {
    this.cache.delete(key);
  }

  clear(): void {
    this.cache.clear();
  }
}
Registering Cache Plugin and Integrating with Query Executor
typescript
Copy code
// FILE: cli.ts (Updated)
import { CachePlugin } from "./src/plugins/CachePlugin.ts";

// ... existing imports and code

if (import.meta.main) {
  // ... existing code

  // Register Plugins with options
  const cachePlugin = new CachePlugin();
  PluginSystem.registerPlugin(cachePlugin);
  PluginSystem.registerPlugin(new LoggingPlugin({
    level: "debug",
    backend: "console",
  }));

  // Initialize Query Executor with Plugins
  const queryExecutor = new QueryExecutor(adapter, cachePlugin);

  // ... existing switch case
}
==== Testing and Documentation
Unit Tests:

For each module (adapters, models, query, migrations, plugins), create targeted unit tests.
Use mocks or in-memory DB for testing logic in isolation.
typescript
Copy code
// FILE: tests/PostgresAdapter.test.ts
import { PostgresAdapter } from "../src/adapters/PostgresAdapter.ts";
import { assertEquals, assertThrowsAsync } from "https://deno.land/std@0.190.0/testing/asserts.ts";

Deno.test("PostgresAdapter connects and disconnects successfully", async () => {
  const config = {
    type: "postgres",
    host: "localhost",
    user: "test_user",
    password: "test_password",
    port: 5432,
    database: "test_db",
    poolSize: 5,
  };
  const adapter = new PostgresAdapter(config);
  await adapter.connect();
  // Assume we have a test table
  const result = await adapter.execute("SELECT 1");
  assertEquals(result, [[1]]);
  await adapter.disconnect();
});

Deno.test("PostgresAdapter throws error when not connected", async () => {
  const config = {
    type: "postgres",
    host: "localhost",
    user: "test_user",
    password: "test_password",
    port: 5432,
    database: "test_db",
    poolSize: 5,
  };
  const adapter = new PostgresAdapter(config);
  await assertThrowsAsync(
    async () => {
      await adapter.execute("SELECT 1");
    },
    Error,
    "PostgresAdapter not connected."
  );
});
Integration Tests:

Test the entire flow (connect, create a table, insert, query, etc.).
Optionally use Docker containers for a clean environment if testing PostgreSQL.
typescript
Copy code
// FILE: tests/Integration.test.ts
import { DatabaseFactory } from "../src/adapters/DatabaseFactory.ts";
import { Repository } from "../src/models/Repository.ts";
import { User } from "../src/models/User.ts";
import { assertEquals } from "https://deno.land/std@0.190.0/testing/asserts.ts";

Deno.test("Full CRUD cycle for User", async () => {
  const config = {
    type: "sqlite",
    filePath: ":memory:",
  };
  const adapter = DatabaseFactory.createAdapter(config);
  await adapter.connect();

  // Create migration runner and apply migrations
  const runner = new MigrationRunner(adapter, "./src/migrations");
  await runner.applyMigrations();

  const userRepo = new Repository<User>(adapter, User);

  // Create
  const user = new User();
  user.name = "John Doe";
  user.email = "john@example.com";
  await userRepo.save(user);

  // Read
  const fetchedUser = await userRepo.findOne(1);
  assertEquals(fetchedUser?.name, "John Doe");

  // Update
  if (fetchedUser) {
    fetchedUser.name = "Jane Doe";
    await userRepo.save(fetchedUser);
  }

  const updatedUser = await userRepo.findOne(1);
  assertEquals(updatedUser?.name, "Jane Doe");

  // Delete
  if (updatedUser) {
    await userRepo.delete(updatedUser, "admin");
  }

  const deletedUser = await userRepo.findOne(1);
  assertEquals(deletedUser, null);

  await adapter.disconnect();
});
Documentation:

Maintain a /docs folder with .md files explaining usage and providing code samples.

Provide a top-level README.md with the main instructions.

Sample README.md:

markdown
Copy code
# Rex-ORM

Rex-ORM is a robust, type-safe Object-Relational Mapping (ORM) library for Deno, designed to simplify database interactions with PostgreSQL and SQLite. It offers a fluent Query Builder, comprehensive migration tools, and an extensible plugin system.

## Features

- **Type Safety**: Leverage TypeScript for compile-time safety.
- **Multiple Database Support**: PostgreSQL and SQLite out of the box.
- **Fluent Query Builder**: Build complex queries with ease.
- **Migration System**: Manage schema changes effectively.
- **Extensible Plugins**: Add caching, advanced logging, and more.
- **CLI Tool**: Automate common ORM tasks.
- **Validation**: Ensure data integrity with decorators.

## Installation

Ensure you have Deno installed. Then, clone the repository:

```bash
git clone https://github.com/yourusername/rex-orm.git
cd rex-orm
Configuration
Create a rex-orm.config.json file:

json
Copy code
{
  "database": {
    "type": "postgres",
    "host": "localhost",
    "user": "admin",
    "password": "password",
    "port": 5432,
    "database": "rexorm_db",
    "poolSize": 10
  },
  "migrationsDir": "./src/migrations",
  "plugins": [
    "./src/plugins/LoggingPlugin.ts"
  ]
}
Usage
Running Migrations
bash
Copy code
deno run --allow-net --allow-read --allow-write cli.ts migrate
Generating a Model
bash
Copy code
deno run cli.ts generate:model User
Using the Repository
typescript
Copy code
import { DatabaseFactory } from "./src/adapters/DatabaseFactory.ts";
import { Repository } from "./src/models/Repository.ts";
import { User } from "./src/models/User.ts";

const config = {
  type: "postgres",
  host: "localhost",
  user: "admin",
  password: "password",
  port: 5432,
  database: "rexorm_db",
  poolSize: 10,
};

const adapter = DatabaseFactory.createAdapter(config);
await adapter.connect();

const userRepo = new Repository<User>(adapter, User);

// Create a new user
const user = new User();
user.name = "Alice";
user.email = "alice@example.com";
await userRepo.save(user);

// Fetch user by ID
const fetchedUser = await userRepo.findOne(1);
console.log(fetchedUser);

await adapter.disconnect();
Contributing
Contributions are welcome! Please fork the repository and submit a pull request.

License
MIT License

Copy code
Detailed /docs Content:

Getting Started: Step-by-step guide to setting up Rex-ORM.
Model Definitions: In-depth explanations of decorators and relationships.
Query Builder Usage: Comprehensive examples of building various queries.
Migration Management: Best practices and advanced migration techniques.
Plugin Development: How to create and integrate plugins.
CLI Commands: Detailed descriptions of all CLI commands and options.
Advanced Topics: Eager vs. lazy loading, nested transactions, performance optimizations.
Troubleshooting: Common issues and their resolutions.
==== Expanded Testing Strategies
Mocking Database Adapters

Purpose: Test repositories and services without relying on a real database.

Example Mock Adapter:

typescript
Copy code
// FILE: tests/mocks/MockAdapter.ts
import { DatabaseAdapter } from "../../src/adapters/interfaces/DatabaseAdapter.ts";

export class MockAdapter implements DatabaseAdapter {
  private data: Record<string, any[]> = {};

  async connect(): Promise<void> {}
  async disconnect(): Promise<void> {}
  async execute(query: string, params: any[] = []): Promise<any> {
    // Simple in-memory query simulation
    if (query.startsWith("SELECT")) {
      const table = query.split("FROM ")[1].split(" ")[0];
      return this.data[table] || [];
    } else if (query.startsWith("INSERT")) {
      const table = query.split("INTO ")[1].split(" ")[0];
      const values = params;
      if (!this.data[table]) this.data[table] = [];
      this.data[table].push(Object.fromEntries(values.map((v, i) => [`col${i}`, v])));
    }
    // Implement other query types as needed
    return [];
  }

  async beginTransaction(): Promise<void> {}
  async commitTransaction(): Promise<void> {}
  async rollbackTransaction(): Promise<void> {}
}
Using Mock Adapter in Tests:

typescript
Copy code
// FILE: tests/Repository.test.ts
import { Repository } from "../src/models/Repository.ts";
import { User } from "../src/models/User.ts";
import { MockAdapter } from "./mocks/MockAdapter.ts";
import { assertEquals } from "https://deno.land/std@0.190.0/testing/asserts.ts";

Deno.test("Repository save and findOne with MockAdapter", async () => {
  const adapter = new MockAdapter();
  await adapter.connect();

  const userRepo = new Repository<User>(adapter, User);

  const user = new User();
  user.name = "Test User";
  user.email = "test@example.com";
  await userRepo.save(user);

  const fetchedUsers = await userRepo.findMany({ name: "Test User" });
  assertEquals(fetchedUsers.length, 1);
  assertEquals(fetchedUsers[0].email, "test@example.com");

  await adapter.disconnect();
});
Coverage Reports

Utilize Denoâ€™s built-in coverage tools to ensure high test coverage.
bash
Copy code
deno test --coverage=cov_profile
deno coverage cov_profile --lcov > coverage.lcov
Integrate coverage reporting in CI pipelines.
Testing Lifecycle Hooks

Test that event listeners are triggered appropriately.
typescript
Copy code
// FILE: tests/EventEmitter.test.ts
import { Repository } from "../src/models/Repository.ts";
import { User } from "../src/models/User.ts";
import { MockAdapter } from "./mocks/MockAdapter.ts";
import { assertEquals } from "https://deno.land/std@0.190.0/testing/asserts.ts";

Deno.test("Repository emits beforeSave and afterSave events", async () => {
  const adapter = new MockAdapter();
  await adapter.connect();

  const userRepo = new Repository<User>(adapter, User);

  let beforeSaveCalled = false;
  let afterSaveCalled = false;

  userRepo.on("beforeSave", (entity) => {
    beforeSaveCalled = true;
    assertEquals((entity as User).name, "Event User");
  });

  userRepo.on("afterSave", (entity) => {
    afterSaveCalled = true;
    assertEquals((entity as User).email, "event@example.com");
  });

  const user = new User();
  user.name = "Event User";
  user.email = "event@example.com";
  await userRepo.save(user);

  assertEquals(beforeSaveCalled, true);
  assertEquals(afterSaveCalled, true);

  await adapter.disconnect();
});
Integration Testing with Real Databases

Use Docker containers to spin up PostgreSQL instances for testing.

Example Docker Setup:

bash
Copy code
docker run --name rexorm_test_db -e POSTGRES_USER=test_user -e POSTGRES_PASSWORD=test_password -e POSTGRES_DB=test_db -p 5432:5432 -d postgres
Running Integration Tests Against Docker DB:

typescript
Copy code
// FILE: tests/IntegrationPostgres.test.ts
import { DatabaseFactory } from "../src/adapters/DatabaseFactory.ts";
import { Repository } from "../src/models/Repository.ts";
import { User } from "../src/models/User.ts";
import { MigrationRunner } from "../src/migrations/MigrationRunner.ts";
import { assertEquals } from "https://deno.land/std@0.190.0/testing/asserts.ts";

Deno.test("PostgresAdapter Integration Test", async () => {
  const config = {
    type: "postgres",
    host: "localhost",
    user: "test_user",
    password: "test_password",
    port: 5432,
    database: "test_db",
    poolSize: 5,
  };
  const adapter = DatabaseFactory.createAdapter(config);
  await adapter.connect();

  const runner = new MigrationRunner(adapter, "./src/migrations");
  await runner.applyMigrations();

  const userRepo = new Repository<User>(adapter, User);

  // Create
  const user = new User();
  user.name = "Integration Test";
  user.email = "integration@example.com";
  await userRepo.save(user);

  // Read
  const fetchedUser = await userRepo.findOne(1);
  assertEquals(fetchedUser?.name, "Integration Test");

  // Clean up
  await runner.rollbackMigrations();

  await adapter.disconnect();
});
==== Logging Enhancements (Extended)
Structured Logging

Log messages in a structured format (e.g., JSON) for easier parsing and analysis.
typescript
Copy code
// FILE: src/plugins/StructuredLoggingPlugin.ts
import { ORMPlugin } from "./PluginSystem.ts";

export class StructuredLoggingPlugin implements ORMPlugin {
  name = "StructuredLoggingPlugin";

  initialize() {
    console.log("StructuredLoggingPlugin initialized.");
  }

  beforeQuery(query: string, params: any[]) {
    this.log("info", {
      event: "beforeQuery",
      query,
      params,
      timestamp: new Date().toISOString(),
    });
  }

  afterQuery(query: string, params: any[], result: any) {
    this.log("info", {
      event: "afterQuery",
      query,
      params,
      result,
      timestamp: new Date().toISOString(),
    });
  }

  private log(level: string, data: object) {
    console.log(JSON.stringify({ level, ...data }));
  }
}
Log Rotation

Implement log rotation to manage log file sizes when using file-based logging.
typescript
Copy code
// FILE: src/plugins/FileLoggingPlugin.ts
import { ORMPlugin } from "./PluginSystem.ts";
import { exists, ensureFile } from "https://deno.land/std@0.190.0/fs/mod.ts";

export class FileLoggingPlugin implements ORMPlugin {
  name = "FileLoggingPlugin";
  private filePath: string;

  constructor(filePath: string) {
    this.filePath = filePath;
  }

  async initialize() {
    await ensureFile(this.filePath);
    console.log(`FileLoggingPlugin initialized. Logging to ${this.filePath}`);
  }

  beforeQuery(query: string, params: any[]) {
    this.log("DEBUG", `Executing Query: ${query} with params: ${JSON.stringify(params)}`);
  }

  afterQuery(query: string, params: any[], result: any) {
    this.log("INFO", `Query Result: ${JSON.stringify(result)}`);
  }

  private async log(level: string, message: string) {
    const logMessage = `[${new Date().toISOString()}] [${level}] ${message}\n`;
    await Deno.writeTextFile(this.filePath, logMessage, { append: true });
  }
}
External Logging Services Integration

Send logs to external services like Logstash, Elasticsearch, or cloud-based logging services.
typescript
Copy code
// FILE: src/plugins/ExternalLoggingPlugin.ts
import { ORMPlugin } from "./PluginSystem.ts";

export class ExternalLoggingPlugin implements ORMPlugin {
  name = "ExternalLoggingPlugin";
  private serviceUrl: string;

  constructor(serviceUrl: string) {
    this.serviceUrl = serviceUrl;
  }

  initialize() {
    console.log(`ExternalLoggingPlugin initialized. Sending logs to ${this.serviceUrl}`);
  }

  async beforeQuery(query: string, params: any[]) {
    await this.sendLog({
      event: "beforeQuery",
      query,
      params,
      timestamp: new Date().toISOString(),
    });
  }

  async afterQuery(query: string, params: any[], result: any) {
    await this.sendLog({
      event: "afterQuery",
      query,
      params,
      result,
      timestamp: new Date().toISOString(),
    });
  }

  private async sendLog(log: object) {
    try {
      await fetch(this.serviceUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(log),
      });
    } catch (err) {
      console.error(`Failed to send log to external service: ${err.message}`);
    }
  }
}
==== Security Enhancements
SQL Injection Prevention

Enforce the use of parameterized queries within the Query Builder and Repository methods.
Example Enforcement:
typescript
Copy code
// FILE: src/query/QueryBuilder.ts (Updated)
export class QueryBuilder {
  // ... existing properties and methods

  buildQuery(): { sql: string, params: any[] } {
    if (!this._from) {
      throw new Error("No table specified in QueryBuilder.");
    }

    const selectClause = this._select.length > 0 ? this._select.join(", ") : "*";
    let query = `SELECT ${selectClause} FROM ${this._from}`;
    const params: any[] = [];

    if (this._joins.length) {
      for (const j of this._joins) {
        query += ` ${j.type} JOIN ${j.table} ON ${j.condition}`;
      }
    }

    if (this._whereClauses.length) {
      const conditions = this._whereClauses
        .map((w, i) => {
          params.push(w.value);
          return `${w.column} ${w.operator} $${i + 1}`;
        })
        .join(" AND ");
      query += ` WHERE ${conditions}`;
    }

    if (this._groupBy.length) {
      query += ` GROUP BY ${this._groupBy.join(", ")}`;
    }

    if (this._having) {
      query += ` HAVING ${this._having}`;
    }

    if (this._orderBy) {
      query += ` ORDER BY ${this._orderBy}`;
    }

    if (this._limit !== null) {
      query += ` LIMIT ${this._limit}`;
    }

    if (this._offset !== null) {
      query += ` OFFSET ${this._offset}`;
    }

    return { sql: query, params };
  }

  async execute(adapter: DatabaseAdapter): Promise<any> {
    const { sql, params } = this.buildQuery();
    return await adapter.execute(sql, params);
  }
}
Data Encryption

At-Rest Encryption: Use encrypted databases or encrypted storage for sensitive data.
In-Transit Encryption: Ensure connections use SSL/TLS.
Example PostgreSQL SSL Connection:
typescript
Copy code
// FILE: src/adapters/PostgresAdapter.ts (Updated)
import { PostgresClient, PostgresPool } from "../../deps.ts";
import { DatabaseAdapter } from "./interfaces/DatabaseAdapter.ts";
import { PluginSystem } from "../plugins/PluginSystem.ts";

interface PostgresConfig {
  // ... existing properties
  ssl?: boolean;
  sslMode?: "disable" | "allow" | "prefer" | "require" | "verify-ca" | "verify-full";
}

export class PostgresAdapter implements DatabaseAdapter {
  // ... existing properties and methods

  async connect() {
    this.pool = new PostgresPool({
      hostname: this.config.host,
      user: this.config.user,
      password: this.config.password,
      port: this.config.port,
      database: this.config.database,
      tls: this.config.ssl ? { rejectUnauthorized: this.config.sslMode === "verify-full" } : undefined,
    }, this.config.poolSize || 5);
  }

  // ... existing methods
}
Access Control and Permissions

Implement granular access controls at the ORM level to restrict which models or fields can be accessed or modified by different roles.
typescript
Copy code
// FILE: src/security/AccessControl.ts
import { Role } from "./RBAC.ts";

interface AccessRules {
  [role in Role]?: {
    read?: string[];
    write?: string[];
  };
}

export class AccessControl {
  private rules: AccessRules;

  constructor(rules: AccessRules) {
    this.rules = rules;
  }

  canRead(role: Role, field: string): boolean {
    return this.rules[role]?.read?.includes(field) ?? false;
  }

  canWrite(role: Role, field: string): boolean {
    return this.rules[role]?.write?.includes(field) ?? false;
  }
}
Integrating AccessControl with Repository
typescript
Copy code
// FILE: src/models/Repository.ts (Extended with Access Control)
import { AccessControl } from "../security/AccessControl.ts";
import { Role } from "../security/RBAC.ts";
import { AuthorizationError } from "../errors/AuthorizationError.ts";

export class Repository<T> {
  private accessControl: AccessControl;

  constructor(private adapter: DatabaseAdapter, private model: { new (): T }, accessRules: AccessRules) {
    this.accessControl = new AccessControl(accessRules);
  }

  async update(entity: T, updates: Partial<T>, role: Role): Promise<void> {
    // Check write permissions
    for (const field of Object.keys(updates)) {
      if (!this.accessControl.canWrite(role, field)) {
        throw new AuthorizationError(`Role ${role} cannot write to field ${field}.`);
      }
    }

    // Proceed with update
    // ...
  }

  // Other methods with access control checks
}
Secure Error Reporting

Avoid exposing sensitive information in error messages.
Provide generic error messages to end-users while logging detailed errors internally.
typescript
Copy code
// FILE: src/errors/DatabaseError.ts
export class DatabaseError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "DatabaseError";
  }
}

// FILE: src/adapters/PostgresAdapter.ts (Updated Error Handling)
export class PostgresAdapter implements DatabaseAdapter {
  // ... existing properties and methods

  async execute(query: string, params: any[] = []): Promise<any> {
    if (!this.pool) {
      throw new DatabaseError("Database connection is not established.");
    }

    // Execute beforeQuery plugins
    await PluginSystem.executeBeforeQuery(query, params);

    const client = await this.pool.connect();
    try {
      const result = await client.queryArray(query, ...params);

      // Execute afterQuery plugins
      await PluginSystem.executeAfterQuery(query, params, result.rows);

      return result.rows;
    } catch (err) {
      // Log detailed error internally
      console.error(`Database execution error: ${err.message}`);
      throw new DatabaseError("An error occurred while executing the database query.");
    } finally {
      client.release();
    }
  }

  // ... existing methods
}
==== Performance Evaluation
Benchmarking Queries

Use Denoâ€™s benchmarking tools or external tools like pgbench for PostgreSQL.
typescript
Copy code
// FILE: tests/Benchmark.test.ts
import { DatabaseFactory } from "../src/adapters/DatabaseFactory.ts";
import { QueryBuilder } from "../src/query/QueryBuilder.ts";
import { Benchmark, runBenchmarks } from "https://deno.land/x/bench/mod.ts";

const adapter = DatabaseFactory.createAdapter({
  type: "sqlite",
  filePath: ":memory:",
});

await adapter.connect();
// Apply necessary migrations
// ...

const qb = new QueryBuilder().select('*').from('users').where('id', '=', 1);

const benchmark = new Benchmark({
  name: "Simple Select Query",
  fn: async () => {
    await qb.execute(adapter);
  },
});

await runBenchmarks([benchmark]);

await adapter.disconnect();
Profiling Resource Usage

Use Denoâ€™s built-in profiling tools to analyze CPU and memory usage.
bash
Copy code
deno test --allow-net --allow-read --allow-write --profile=profile_output.json
Analyzing the Profile:
bash
Copy code
deno profile report profile_output.json
Load Testing

Simulate high-load scenarios to assess performance under stress.
Example with Deno Scripts:
typescript
Copy code
// FILE: tests/LoadTest.ts
import { DatabaseFactory } from "../src/adapters/DatabaseFactory.ts";
import { Repository } from "../src/models/Repository.ts";
import { User } from "../src/models/User.ts";

const adapter = DatabaseFactory.createAdapter({
  type: "sqlite",
  filePath: ":memory:",
});
await adapter.connect();
// Apply migrations
// ...

const userRepo = new Repository<User>(adapter, User);

const concurrentTasks = 100;
const promises = [];

for (let i = 0; i < concurrentTasks; i++) {
  const user = new User();
  user.name = `User ${i}`;
  user.email = `user${i}@example.com`;
  promises.push(userRepo.save(user));
}

await Promise.all(promises);
console.log(`${concurrentTasks} users inserted successfully.`);

await adapter.disconnect();
Optimizing Query Building

Avoid unnecessary computations and optimize query construction logic.
Example Optimization:
typescript
Copy code
// FILE: src/query/QueryBuilder.ts (Optimized)
export class QueryBuilder {
  // ... existing properties and methods

  private paramIndex = 1;
  private params: any[] = [];

  where(column: string, operator: string, value: any) {
    this._whereClauses.push({ column, operator, value, paramIndex: this.paramIndex++ });
    this.params.push(value);
    return this;
  }

  buildQuery(): { sql: string, params: any[] } {
    if (!this._from) {
      throw new Error("No table specified in QueryBuilder.");
    }

    const selectClause = this._select.length > 0 ? this._select.join(", ") : "*";
    let query = `SELECT ${selectClause} FROM ${this._from}`;

    if (this._joins.length) {
      for (const j of this._joins) {
        query += ` ${j.type} JOIN ${j.table} ON ${j.condition}`;
      }
    }

    if (this._whereClauses.length) {
      const conditions = this._whereClauses
        .map(w => `${w.column} ${w.operator} $${w.paramIndex}`)
        .join(" AND ");
      query += ` WHERE ${conditions}`;
    }

    // ... rest of the query building

    return { sql: query, params: this.params };
  }

  async execute(adapter: DatabaseAdapter): Promise<any> {
    const { sql, params } = this.buildQuery();
    return await adapter.execute(sql, params);
  }
}
Caching Strategies

Implement read-through and write-through caching mechanisms.
typescript
Copy code
// FILE: src/plugins/CachingStrategies.ts
import { CachePlugin } from "./CachePlugin.ts";

export class ReadThroughCache extends CachePlugin {
  async beforeQuery(query: string, params: any[]): Promise<void> {
    const cacheKey = this.generateKey(query, params);
    const cachedResult = this.get(cacheKey);
    if (cachedResult) {
      // Short-circuit the query execution by returning the cached result
      // This requires modifying the QueryExecutor to handle this scenario
    }
  }

  async afterQuery(query: string, params: any[], result: any): Promise<void> {
    const cacheKey = this.generateKey(query, params);
    this.set(cacheKey, result);
  }
}

export class WriteThroughCache extends CachePlugin {
  async afterQuery(query: string, params: any[], result: any): Promise<void> {
    // Invalidate or update cache entries based on the query type
    if (query.startsWith("INSERT") || query.startsWith("UPDATE") || query.startsWith("DELETE")) {
      this.invalidateAll(); // Simplistic approach; can be optimized
    }
  }
}
== Implementation
Below is a step-by-step guide for implementing Rex-ORM, complete with file paths and expanded code examples.

=== Step 1: Project Setup
Initialize Deno Project

bash
Copy code
mkdir rex-orm && cd rex-orm
mkdir src tests docs
# Optionally create a tsconfig:
echo '{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "target": "ESNext",
    "module": "ESNext",
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true
  }
}' > tsconfig.json
Explanation:
"emitDecoratorMetadata": true and "experimentalDecorators": true are required for using decorators and reflect metadata.
Setup Dependencies Management

typescript
Copy code
// FILE: src/deps.ts
export { Client as PostgresClient, Pool as PostgresPool } from "https://deno.land/x/postgres/mod.ts";
export { DB as SQLiteDB } from "https://deno.land/x/sqlite/mod.ts";
export { config as loadEnv } from "https://deno.land/x/dotenv/mod.ts";
export { assertEquals, assertThrowsAsync } from "https://deno.land/std@0.190.0/testing/asserts.ts";
export { join, extname } from "https://deno.land/std@0.190.0/path/mod.ts";
export { ensureFile, exists } from "https://deno.land/std@0.190.0/fs/mod.ts";
Setup Testing Framework

Deno provides a built-in test runner. Create a basic test in tests/sample.test.ts:

typescript
Copy code
// FILE: tests/sample.test.ts
import { assertEquals } from "../src/deps.ts";

Deno.test("Basic addition test", () => {
  const sum = 2 + 2;
  assertEquals(sum, 4);
});
Run tests with:

bash
Copy code
deno test --config tsconfig.json --coverage
Setup Git and Initial Commit

bash
Copy code
git init
git add .
git commit -m "Initial commit with project setup"
=== Step 2: Build the Database Connector
DatabaseAdapter Interface

typescript
Copy code
// FILE: src/adapters/interfaces/DatabaseAdapter.ts
export interface DatabaseAdapter {
  connect(): Promise<void>;
  disconnect(): Promise<void>;
  execute(query: string, params?: any[]): Promise<any>;
  beginTransaction?(): Promise<void>;
  commitTransaction?(): Promise<void>;
  rollbackTransaction?(): Promise<void>;
  savepoint?(name: string): Promise<void>;
  releaseSavepoint?(name: string): Promise<void>;
  rollbackToSavepoint?(name: string): Promise<void>;
}
PostgreSQL Adapter

typescript
Copy code
// FILE: src/adapters/PostgresAdapter.ts
import { PostgresPool } from "../deps.ts";
import { DatabaseAdapter } from "./interfaces/DatabaseAdapter.ts";
import { MigrationError } from "../migrations/MigrationRunner.ts";

interface PostgresConfig {
  type: "postgres";
  host: string;
  user: string;
  password: string;
  port: number;
  database: string;
  poolSize?: number;
  ssl?: boolean;
  sslMode?: "disable" | "allow" | "prefer" | "require" | "verify-ca" | "verify-full";
}

export class PostgresAdapter implements DatabaseAdapter {
  private pool: PostgresPool | null = null;

  constructor(private config: PostgresConfig) {}

  async connect() {
    this.pool = new PostgresPool({
      hostname: this.config.host,
      user: this.config.user,
      password: this.config.password,
      port: this.config.port,
      database: this.config.database,
      tls: this.config.ssl ? { rejectUnauthorized: this.config.sslMode === "verify-full" } : undefined,
    }, this.config.poolSize || 5);
    console.log("PostgresAdapter connected.");
  }

  async disconnect() {
    if (this.pool) {
      await this.pool.end();
      this.pool = null;
      console.log("PostgresAdapter disconnected.");
    }
  }

  async execute(query: string, params: any[] = []): Promise<any> {
    if (!this.pool) {
      throw new MigrationError("PostgresAdapter not connected.");
    }

    // Execute beforeQuery plugins
    // await PluginSystem.executeBeforeQuery(query, params); // To be integrated

    const client = await this.pool.connect();
    try {
      const result = await client.queryObject(query, ...params);

      // Execute afterQuery plugins
      // await PluginSystem.executeAfterQuery(query, params, result.rows); // To be integrated

      return result.rows;
    } catch (err) {
      console.error(`Database execution error: ${err.message}`);
      throw new MigrationError("An error occurred while executing the database query.");
    } finally {
      client.release();
    }
  }

  async beginTransaction(): Promise<void> {
    await this.execute("BEGIN");
  }

  async commitTransaction(): Promise<void> {
    await this.execute("COMMIT");
  }

  async rollbackTransaction(): Promise<void> {
    await this.execute("ROLLBACK");
  }

  async savepoint(name: string): Promise<void> {
    await this.execute(`SAVEPOINT ${name}`);
  }

  async releaseSavepoint(name: string): Promise<void> {
    await this.execute(`RELEASE SAVEPOINT ${name}`);
  }

  async rollbackToSavepoint(name: string): Promise<void> {
    await this.execute(`ROLLBACK TO SAVEPOINT ${name}`);
  }
}
SQLite Adapter

typescript
Copy code
// FILE: src/adapters/SQLiteAdapter.ts
import { SQLiteDB } from "../deps.ts";
import { DatabaseAdapter } from "./interfaces/DatabaseAdapter.ts";
import { MigrationError } from "../migrations/MigrationRunner.ts";

interface SQLiteConfig {
  type: "sqlite";
  filePath: string; // e.g. "./database.sqlite" or ":memory:"
}

export class SQLiteAdapter implements DatabaseAdapter {
  private db!: SQLiteDB;
  private connected = false;

  constructor(private config: SQLiteConfig) {}

  async connect(): Promise<void> {
    this.db = new SQLiteDB(this.config.filePath);
    this.connected = true;
    console.log("SQLiteAdapter connected.");
  }

  async disconnect(): Promise<void> {
    if (this.connected) {
      this.db.close();
      this.connected = false;
      console.log("SQLiteAdapter disconnected.");
    }
  }

  async execute(query: string, params: any[] = []): Promise<any> {
    if (!this.connected) throw new MigrationError("SQLiteAdapter not connected.");

    try {
      const result = this.db.query(query, params);
      return result;
    } catch (err) {
      console.error(`Database execution error: ${err.message}`);
      throw new MigrationError("An error occurred while executing the database query.");
    }
  }

  async beginTransaction(): Promise<void> {
    await this.execute("BEGIN TRANSACTION;");
  }

  async commitTransaction(): Promise<void> {
    await this.execute("COMMIT;");
  }

  async rollbackTransaction(): Promise<void> {
    await this.execute("ROLLBACK;");
  }
}
Database Factory

typescript
Copy code
// FILE: src/adapters/DatabaseFactory.ts
import { DatabaseAdapter } from "./interfaces/DatabaseAdapter.ts";
import { PostgresAdapter } from "./PostgresAdapter.ts";
import { SQLiteAdapter } from "./SQLiteAdapter.ts";

export class DatabaseFactory {
  static createAdapter(config: any): DatabaseAdapter {
    if (config.type === "postgres") {
      return new PostgresAdapter(config);
    } else if (config.type === "sqlite") {
      return new SQLiteAdapter(config);
    } else {
      throw new Error(`Unsupported database type: ${config.type}`);
    }
  }
}
=== Step 3: Model Layer
Decorators

typescript
Copy code
// FILE: src/models/decorators.ts
import "https://deno.land/x/reflect_metadata@v0.1.12/mod.ts";

export function Entity(tableName: string) {
  return function (target: any) {
    Reflect.defineMetadata("tableName", tableName, target);
  };
}

export function PrimaryKey() {
  return function (target: any, propertyKey: string) {
    Reflect.defineMetadata("primaryKey", propertyKey, target.constructor);
  };
}

export function Column(options?: Record<string, any>) {
  return function (target: any, propertyKey: string) {
    const columns = Reflect.getMetadata("columns", target.constructor) || [];
    columns.push({ propertyKey, options });
    Reflect.defineMetadata("columns", columns, target.constructor);
  };
}
Relationship Decorators

typescript
Copy code
// FILE: src/models/relationships.ts
import "https://deno.land/x/reflect_metadata@v0.1.12/mod.ts";

export function OneToMany(relatedClass: () => any, mappedBy?: string) {
  return function (target: any, propertyKey: string) {
    const relationships = Reflect.getMetadata("relationships", target.constructor) || [];
    relationships.push({
      type: "OneToMany",
      propertyKey,
      relatedClass: relatedClass(),
      mappedBy,
    });
    Reflect.defineMetadata("relationships", relationships, target.constructor);
  };
}

export function ManyToOne(relatedClass: () => any) {
  return function (target: any, propertyKey: string) {
    const relationships = Reflect.getMetadata("relationships", target.constructor) || [];
    relationships.push({
      type: "ManyToOne",
      propertyKey,
      relatedClass: relatedClass(),
    });
    Reflect.defineMetadata("relationships", relationships, target.constructor);
  };
}

export function OneToOne(relatedClass: () => any) {
  return function (target: any, propertyKey: string) {
    const relationships = Reflect.getMetadata("relationships", target.constructor) || [];
    relationships.push({
      type: "OneToOne",
      propertyKey,
      relatedClass: relatedClass(),
    });
    Reflect.defineMetadata("relationships", relationships, target.constructor);
  };
}

export function ManyToMany(relatedClass: () => any, joinTable?: string) {
  return function (target: any, propertyKey: string) {
    const relationships = Reflect.getMetadata("relationships", target.constructor) || [];
    relationships.push({
      type: "ManyToMany",
      propertyKey,
      relatedClass: relatedClass(),
      joinTable,
    });
    Reflect.defineMetadata("relationships", relationships, target.constructor);
  };
}
Example Models

typescript
Copy code
// FILE: src/models/User.ts
import { Entity, PrimaryKey, Column } from "./decorators.ts";
import { OneToMany } from "./relationships.ts";
import { Post } from "./Post.ts";

@Entity("users")
export class User {
  @PrimaryKey()
  id!: number;

  @Column({ type: "varchar", length: 255, nullable: false })
  name!: string;

  @Column({ type: "varchar", length: 255, unique: true, nullable: false })
  email!: string;

  @OneToMany(() => Post, "user")
  posts?: Post[];
}
typescript
Copy code
// FILE: src/models/Post.ts
import { Entity, PrimaryKey, Column } from "./decorators.ts";
import { ManyToOne } from "./relationships.ts";
import { User } from "./User.ts";

@Entity("posts")
export class Post {
  @PrimaryKey()
  id!: number;

  @Column({ type: "varchar", length: 255, nullable: false })
  title!: string;

  @Column({ type: "text", nullable: false })
  content!: string;

  @ManyToOne(() => User)
  user?: User;
}
Advanced Model Features

Timestamps

typescript
Copy code
// FILE: src/models/decorators.ts (Extended)
export function CreatedAt() {
  return function (target: any, propertyKey: string) {
    Reflect.defineMetadata("createdAt", propertyKey, target.constructor);
  };
}

export function UpdatedAt() {
  return function (target: any, propertyKey: string) {
    Reflect.defineMetadata("updatedAt", propertyKey, target.constructor);
  };
}
Using Timestamps in Models

typescript
Copy code
// FILE: src/models/User.ts (Extended)
import { Entity, PrimaryKey, Column, CreatedAt, UpdatedAt } from "./decorators.ts";
import { OneToMany } from "./relationships.ts";
import { Post } from "./Post.ts";

@Entity("users")
export class User {
  @PrimaryKey()
  id!: number;

  @Column({ type: "varchar", length: 255, nullable: false })
  name!: string;

  @Column({ type: "varchar", length: 255, unique: true, nullable: false })
  email!: string;

  @OneToMany(() => Post, "user")
  posts?: Post[];

  @CreatedAt()
  createdAt!: Date;

  @UpdatedAt()
  updatedAt!: Date;
}
Automating Timestamps in Repository

typescript
Copy code
// FILE: src/models/Repository.ts (Extended with Timestamps)
export class Repository<T> {
  // ... existing constructor and methods

  async save(entity: T): Promise<void> {
    // Emit beforeSave event
    this.eventEmitter.emit({ name: "beforeSave", data: entity });

    // Handle createdAt and updatedAt
    const createdAtProp = Reflect.getMetadata("createdAt", this.model);
    const updatedAtProp = Reflect.getMetadata("updatedAt", this.model);

    if (createdAtProp && !(entity as any)[createdAtProp]) {
      (entity as any)[createdAtProp] = new Date();
    }
    if (updatedAtProp) {
      (entity as any)[updatedAtProp] = new Date();
    }

    // Validate and save entity
    // ...

    // Emit afterSave event
    this.eventEmitter.emit({ name: "afterSave", data: entity });
  }

  // ... other methods
}
=== Step 4: Query Builder
Below is a more comprehensive version with added functionality.

typescript
Copy code
// FILE: src/query/QueryBuilder.ts
import { DatabaseAdapter } from "../adapters/interfaces/DatabaseAdapter.ts";

interface WhereClause {
  column: string;
  operator: string;
  value: any;
  paramIndex: number;
}

interface JoinClause {
  type: "INNER" | "LEFT" | "RIGHT" | "FULL";
  table: string;
  condition: string;
}

export class QueryBuilder {
  private _select: string[] = [];
  private _from: string | null = null;
  private _whereClauses: WhereClause[] = [];
  private _joins: JoinClause[] = [];
  private _groupBy: string[] = [];
  private _having: string | null = null;
  private _orderBy: string | null = null;
  private _limit: number | null = null;
  private _offset: number | null = null;
  private paramIndex = 1;
  private params: any[] = [];

  select(...columns: string[]) {
    this._select = columns;
    return this;
  }

  from(table: string) {
    this._from = table;
    return this;
  }

  where(column: string, operator: string, value: any) {
    this._whereClauses.push({ column, operator, value, paramIndex: this.paramIndex++ });
    this.params.push(value);
    return this;
  }

  andWhere(column: string, operator: string, value: any) {
    return this.where(column, operator, value);
  }

  orWhere(column: string, operator: string, value: any) {
    // Implement OR logic
    // For simplicity, treat as another WHERE clause with OR
    // A more robust implementation would handle grouping and precedence
    this._whereClauses.push({ column, operator, value, paramIndex: this.paramIndex++ });
    this.params.push(value);
    return this;
  }

  join(type: "INNER" | "LEFT" | "RIGHT" | "FULL", table: string, condition: string) {
    this._joins.push({ type, table, condition });
    return this;
  }

  groupBy(...columns: string[]) {
    this._groupBy.push(...columns);
    return this;
  }

  having(condition: string) {
    this._having = condition;
    return this;
  }

  orderBy(column: string, direction: "ASC" | "DESC" = "ASC") {
    this._orderBy = `${column} ${direction}`;
    return this;
  }

  limit(count: number) {
    this._limit = count;
    return this;
  }

  offset(count: number) {
    this._offset = count;
    return this;
  }

  windowFunction(func: string, alias: string, partitionBy?: string, orderBy?: string) {
    const window = `${func} OVER (${partitionBy ? `PARTITION BY ${partitionBy} ` : ""}${orderBy ? `ORDER BY ${orderBy}` : ""}) AS ${alias}`;
    this._select.push(window);
    return this;
  }

  subquery(subBuilder: QueryBuilder, alias: string) {
    const subQuery = `(${subBuilder.buildQuery().sql}) AS ${alias}`;
    this._select.push(subQuery);
    this.params.push(...subBuilder.buildQuery().params);
    return this;
  }

  buildQuery(): { sql: string, params: any[] } {
    if (!this._from) {
      throw new Error("No table specified in QueryBuilder.");
    }

    const selectClause = this._select.length > 0 ? this._select.join(", ") : "*";
    let query = `SELECT ${selectClause} FROM ${this._from}`;
    const params = [...this.params];

    if (this._joins.length) {
      for (const j of this._joins) {
        query += ` ${j.type} JOIN ${j.table} ON ${j.condition}`;
      }
    }

    if (this._whereClauses.length) {
      const conditions = this._whereClauses
        .map(w => `${w.column} ${w.operator} $${w.paramIndex}`)
        .join(" AND ");
      query += ` WHERE ${conditions}`;
    }

    if (this._groupBy.length) {
      query += ` GROUP BY ${this._groupBy.join(", ")}`;
    }

    if (this._having) {
      query += ` HAVING ${this._having}`;
    }

    if (this._orderBy) {
      query += ` ORDER BY ${this._orderBy}`;
    }

    if (this._limit !== null) {
      query += ` LIMIT ${this._limit}`;
    }

    if (this._offset !== null) {
      query += ` OFFSET ${this._offset}`;
    }

    return { sql: query, params };
  }

  async execute(adapter: DatabaseAdapter): Promise<any> {
    const { sql, params } = this.buildQuery();
    return await adapter.execute(sql, params);
  }
}
=== Step 5: Migration System
Migration Runner

typescript
Copy code
// FILE: src/migrations/MigrationRunner.ts
import { DatabaseAdapter } from "../adapters/interfaces/DatabaseAdapter.ts";
import { join, extname } from "../deps.ts";
import { exists } from "../deps.ts";

export class MigrationRunner {
  private migrationTable = "migration_history";

  constructor(private adapter: DatabaseAdapter, private migrationsDir: string) {}

  async initializeMigrationTable() {
    const createTableQuery = `
      CREATE TABLE IF NOT EXISTS ${this.migrationTable} (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL UNIQUE,
        applied_at TIMESTAMP DEFAULT NOW()
      )
    `;
    await this.adapter.execute(createTableQuery);
  }

  async getAppliedMigrations(): Promise<Set<string>> {
    const rows = await this.adapter.execute(`SELECT name FROM ${this.migrationTable}`);
    return new Set(rows.map((row: any) => row.name));
  }

  async loadMigrations(): Promise<any[]> {
    const migrations: any[] = [];
    for await (const dirEntry of Deno.readDir(this.migrationsDir)) {
      if (dirEntry.isFile && extname(dirEntry.name) === ".ts") {
        const migration = await import(join(this.migrationsDir, dirEntry.name));
        migrations.push(migration.default);
      }
    }
    // Sort migrations based on name to ensure order
    migrations.sort((a, b) => a.name.localeCompare(b.name));
    return migrations;
  }

  async applyMigrations() {
    await this.initializeMigrationTable();
    const applied = await this.getAppliedMigrations();
    const migrations = await this.loadMigrations();

    for (const migration of migrations) {
      if (!applied.has(migration.name)) {
        await this.adapter.beginTransaction();
        try {
          await migration.up(this.adapter);
          await this.adapter.execute(`INSERT INTO ${this.migrationTable} (name) VALUES ($1)`, [migration.name]);
          await this.adapter.commitTransaction();
          console.log(`Applied migration: ${migration.name}`);
        } catch (err) {
          await this.adapter.rollbackTransaction();
          throw new MigrationError(`Failed to apply migration ${migration.name}: ${err.message}`);
        }
      }
    }
  }

  async rollbackLastMigration() {
    await this.initializeMigrationTable();
    const rows = await this.adapter.execute(`SELECT name FROM ${this.migrationTable} ORDER BY applied_at DESC LIMIT 1`);
    if (rows.length === 0) {
      console.log("No migrations to rollback.");
      return;
    }
    const lastMigrationName = rows[0].name;
    const migrations = await this.loadMigrations();
    const migration = migrations.find(m => m.name === lastMigrationName);
    if (!migration) {
      throw new MigrationError(`Migration file for ${lastMigrationName} not found.`);
    }

    await this.adapter.beginTransaction();
    try {
      await migration.down(this.adapter);
      await this.adapter.execute(`DELETE FROM ${this.migrationTable} WHERE name = $1`, [migration.name]);
      await this.adapter.commitTransaction();
      console.log(`Rolled back migration: ${migration.name}`);
    } catch (err) {
      await this.adapter.rollbackTransaction();
      throw new MigrationError(`Failed to rollback migration ${migration.name}: ${err.message}`);
    }
  }
}

// Custom Error
export class MigrationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "MigrationError";
  }
}
Example Migration with Indexes and Constraints

typescript
Copy code
// FILE: src/migrations/2_create_posts_table.ts
export default {
  name: "2_create_posts_table",
  up: async (db: any) => {
    await db.execute(`
      CREATE TABLE IF NOT EXISTS posts (
        id SERIAL PRIMARY KEY,
        title VARCHAR(255) NOT NULL,
        content TEXT NOT NULL,
        user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    await db.execute(`CREATE INDEX idx_posts_user_id ON posts(user_id)`);
  },
  down: async (db: any) => {
    await db.execute(`DROP INDEX IF EXISTS idx_posts_user_id;`);
    await db.execute(`DROP TABLE IF EXISTS posts;`);
  },
};
Migration History Table Initialization

typescript
Copy code
// FILE: src/migrations/0_init_migration_table.ts
export default {
  name: "0_init_migration_table",
  up: async (db: any) => {
    await db.execute(`
      CREATE TABLE IF NOT EXISTS migration_history (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL UNIQUE,
        applied_at TIMESTAMP DEFAULT NOW()
      )
    `);
  },
  down: async (db: any) => {
    await db.execute(`DROP TABLE IF EXISTS migration_history;`);
  },
};
Handling Complex Migrations

Adding Columns with Default Values

typescript
Copy code
// FILE: src/migrations/3_add_status_to_users.ts
export default {
  name: "3_add_status_to_users",
  up: async (db: any) => {
    await db.execute(`ALTER TABLE users ADD COLUMN status VARCHAR(50) DEFAULT 'active';`);
  },
  down: async (db: any) => {
    await db.execute(`ALTER TABLE users DROP COLUMN IF EXISTS status;`);
  },
};
Renaming Tables or Columns

typescript
Copy code
// FILE: src/migrations/4_rename_users_to_members.ts
export default {
  name: "4_rename_users_to_members",
  up: async (db: any) => {
    await db.execute(`ALTER TABLE users RENAME TO members;`);
  },
  down: async (db: any) => {
    await db.execute(`ALTER TABLE members RENAME TO users;`);
  },
};
Automating Migration Discovery

As previously implemented in the Migration Runner, automatically discover and load migrations based on file naming conventions and directory scanning.
=== Step 6: CLI Tool
typescript
Copy code
// FILE: cli.ts
import { DatabaseFactory } from "./src/adapters/DatabaseFactory.ts";
import { MigrationRunner, MigrationError } from "./src/migrations/MigrationRunner.ts";
import { LoggingPlugin } from "./src/plugins/LoggingPlugin.ts";
import { CachePlugin } from "./src/plugins/CachePlugin.ts";
import { PluginSystem } from "./src/plugins/PluginSystem.ts";
import { exists, ensureDir } from "./src/deps.ts";

import { config } from "./src/config.ts"; // Assuming a config loader

if (import.meta.main) {
  const [command, ...args] = Deno.args;

  // Load configuration from rex-orm.config.json
  const configPath = "./rex-orm.config.json";
  if (!await exists(configPath)) {
    console.error(`Configuration file ${configPath} not found.`);
    Deno.exit(1);
  }

  const configModule = await import(`./${configPath}`);
  const dbConfig = configModule.default.database;

  // Initialize Database Adapter
  const adapter = DatabaseFactory.createAdapter(dbConfig);

  // Register Plugins with options
  const cachePlugin = new CachePlugin();
  PluginSystem.registerPlugin(cachePlugin);
  PluginSystem.registerPlugin(new LoggingPlugin({
    level: "debug",
    backend: "console",
  }));
  // Register other plugins as needed

  const runner = new MigrationRunner(adapter, configModule.default.migrationsDir || "./src/migrations");

  switch (command) {
    case "migrate":
      try {
        await adapter.connect();
        await runner.applyMigrations();
        await adapter.disconnect();
        console.log("Migrations applied successfully.");
      } catch (err) {
        if (err instanceof MigrationError) {
          console.error(err.message);
        } else {
          console.error(`Unexpected error: ${err.message}`);
        }
        Deno.exit(1);
      }
      break;

    case "rollback":
      try {
        await adapter.connect();
        await runner.rollbackLastMigration();
        await adapter.disconnect();
        console.log("Migration rolled back successfully.");
      } catch (err) {
        if (err instanceof MigrationError) {
          console.error(err.message);
        } else {
          console.error(`Unexpected error: ${err.message}`);
        }
        Deno.exit(1);
      }
      break;

    case "generate:model":
      const modelName = args[0];
      if (!modelName) {
        console.error("Model name is required.");
        Deno.exit(1);
      }
      try {
        await generateModel(modelName);
        console.log(`Model ${modelName} generated successfully.`);
      } catch (err) {
        console.error(`Failed to generate model: ${err.message}`);
        Deno.exit(1);
      }
      break;

    case "generate:migration":
      const migrationName = args[0];
      if (!migrationName) {
        console.error("Migration name is required.");
        Deno.exit(1);
      }
      try {
        await generateMigration(migrationName, runner.migrationsDir);
        console.log(`Migration ${migrationName} generated successfully.`);
      } catch (err) {
        console.error(`Failed to generate migration: ${err.message}`);
        Deno.exit(1);
      }
      break;

    case "help":
    default:
      console.log(`
Rex-ORM CLI

Commands:
  migrate                 Apply all pending migrations.
  rollback                Rollback the last applied migration.
  generate:model <Name>   Generate a new model file.
  generate:migration <Name> Generate a new migration file.
  help                    Show this help message.

Examples:
  deno run --allow-net --allow-read --allow-write cli.ts migrate
  deno run --allow-net --allow-read --allow-write cli.ts rollback
  deno run --allow-read --allow-write cli.ts generate:model User
  deno run --allow-read --allow-write cli.ts generate:migration add_email_to_users
      `);
      break;
  }
}

// Example Model Generator Function
async function generateModel(name: string) {
  const modelsDir = "./src/models/";
  await ensureDir(modelsDir);
  const filePath = `${modelsDir}${name}.ts`;
  const template = `import { Entity, PrimaryKey, Column } from "./decorators.ts";

@Entity("${name.toLowerCase()}s")
export class ${name} {
  @PrimaryKey()
  id!: number;

  @Column({ type: "varchar", length: 255, nullable: false })
  name!: string;

  // Add additional columns as needed
}
`;
  await Deno.writeTextFile(filePath, template);
}

// Example Migration Generator Function
async function generateMigration(name: string, migrationsDir: string) {
  await ensureDir(migrationsDir);
  const timestamp = new Date().toISOString().replace(/[-:.TZ]/g, "");
  const fileName = `${timestamp}_${name}.ts`;
  const filePath = `${migrationsDir}/${fileName}`;
  const template = `export default {
  name: "${timestamp}_${name}",
  up: async (db: any) => {
    // Implement migration logic here
  },
  down: async (db: any) => {
    // Implement rollback logic here
  },
};
`;
  await Deno.writeTextFile(filePath, template);
}
=== Step 7: Testing and Documentation
Unit Tests

Create targeted unit tests for each module.
Example for Decorators:
typescript
Copy code
// FILE: tests/decorators.test.ts
import { Entity, PrimaryKey, Column } from "../src/models/decorators.ts";
import { assertEquals } from "../src/deps.ts";

class TestModel {
  @PrimaryKey()
  id!: number;

  @Column({ type: "varchar", length: 100 })
  name!: string;
}

Deno.test("Entity decorator assigns table name", () => {
  const tableName = Reflect.getMetadata("tableName", TestModel);
  assertEquals(tableName, undefined); // Entity decorator not applied
});

Deno.test("Entity decorator assigns table name correctly", () => {
  @Entity("test_models")
  class ActualTestModel {
    @PrimaryKey()
    id!: number;

    @Column({ type: "varchar", length: 100 })
    name!: string;
  }

  const tableName = Reflect.getMetadata("tableName", ActualTestModel);
  assertEquals(tableName, "test_models");
});
Integration Tests

As shown in Step 4, ensure that repositories interact correctly with real or mock databases.
Documentation

Maintain a /docs folder with .md files.

Example Files:

/docs/getting_started.md
/docs/models.md
/docs/query_builder.md
/docs/migrations.md
/docs/plugins.md
/docs/cli.md
/docs/advanced_topics.md
/docs/troubleshooting.md
Sample getting_started.md:

markdown
Copy code
# Getting Started with Rex-ORM

Welcome to Rex-ORM! This guide will help you set up and start using Rex-ORM in your Deno projects.

## Installation

Ensure you have Deno installed. Clone the Rex-ORM repository and navigate to the project directory:

```bash
git clone https://github.com/yourusername/rex-orm.git
cd rex-orm
Configuration
Create a rex-orm.config.json file in the project root:

json
Copy code
{
  "database": {
    "type": "postgres",
    "host": "localhost",
    "user": "admin",
    "password": "password",
    "port": 5432,
    "database": "rexorm_db",
    "poolSize": 10
  },
  "migrationsDir": "./src/migrations",
  "plugins": [
    "./src/plugins/LoggingPlugin.ts"
  ]
}
Running Migrations
Apply all pending migrations:

bash
Copy code
deno run --allow-net --allow-read --allow-write cli.ts migrate
Rollback the last applied migration:

bash
Copy code
deno run --allow-net --allow-read --allow-write cli.ts rollback
Generating Models
Generate a new model named User:

bash
Copy code
deno run --allow-read --allow-write cli.ts generate:model User
This will create a User.ts file in the src/models/ directory with basic structure.

Using the Repository
typescript
Copy code
import { DatabaseFactory } from "./src/adapters/DatabaseFactory.ts";
import { Repository } from "./src/models/Repository.ts";
import { User } from "./src/models/User.ts";

const config = {
  type: "postgres",
  host: "localhost",
  user: "admin",
  password: "password",
  port: 5432,
  database: "rexorm_db",
  poolSize: 10,
};

const adapter = DatabaseFactory.createAdapter(config);
await adapter.connect();

const userRepo = new Repository<User>(adapter, User);

// Create a new user
const user = new User();
user.name = "Alice";
user.email = "alice@example.com";
await userRepo.save(user);

// Fetch user by ID
const fetchedUser = await userRepo.findOne(1);
console.log(fetchedUser);

await adapter.disconnect();
Next Steps
Explore advanced features like relationships, validation, and plugins.
Refer to the Models and Query Builder documentation for detailed usage.
Copy code
=== Step 8: Continuous Integration and Deployment
GitHub Actions Setup

Example .github/workflows/ci.yml:

yaml
Copy code
name: CI

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install Deno
        uses: denoland/setup-deno@v1
        with:
          deno-version: v1.x
      - name: Lint
        run: deno lint
      - name: Format Check
        run: deno fmt --check
      - name: Test
        run: deno test --allow-env --allow-net --allow-read --allow-write --coverage --config tsconfig.json
      - name: Upload Coverage
        uses: codecov/codecov-action@v3
        with:
          files: coverage/lcov.info
          flags: unittests
          name: codecov-umbrella
```yaml
        name: Upload Coverage
        uses: codecov/codecov-action@v3
        with:
          files: coverage/lcov.info
          flags: unittests
          name: codecov-umbrella
```

### Step 8: Continuous Integration and Deployment (Continued)

#### Setting Up Deployment Pipelines

In addition to running tests and uploading coverage reports, it's essential to automate the deployment of your Rex-ORM-powered applications. Below is an example of how to extend your GitHub Actions workflow to include deployment steps.

##### Example Deployment to a Remote Server

Assuming you have a remote server where you want to deploy your application, you can use SSH to transfer files and restart services.

```yaml
      deploy:
        needs: build-and-test
        runs-on: ubuntu-latest
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        steps:
          - uses: actions/checkout@v2

          - name: Set up Deno
            uses: denoland/setup-deno@v1
            with:
              deno-version: v1.x

          - name: Build Application
            run: deno run --allow-read --allow-write --allow-net src/cli.ts build

          - name: Deploy to Server
            uses: appleboy/scp-action@v0.1.3
            with:
              host: ${{ secrets.SERVER_HOST }}
              username: ${{ secrets.SERVER_USER }}
              password: ${{ secrets.SERVER_PASSWORD }}
              source: "dist/"
              target: "/var/www/rexorm_app/"

          - name: SSH Commands
            uses: appleboy/ssh-action@v0.1.3
            with:
              host: ${{ secrets.SERVER_HOST }}
              username: ${{ secrets.SERVER_USER }}
              password: ${{ secrets.SERVER_PASSWORD }}
              script: |
                cd /var/www/rexorm_app/
                deno run --allow-net --allow-read --allow-write src/main.ts
                pm2 restart rexorm_app || pm2 start src/main.ts --name rexorm_app
```

**Explanation:**

- **Build Application**: Runs your build script to prepare the application for deployment.
- **Deploy to Server**: Uses the `scp-action` to securely copy the built application to your remote server.
- **SSH Commands**: Connects to your server via SSH and runs commands to start or restart your application. This example uses `pm2` for process management, ensuring your application runs continuously.

**Secrets Management:**

Ensure that sensitive information like `SERVER_HOST`, `SERVER_USER`, and `SERVER_PASSWORD` are stored securely in GitHub Secrets. Navigate to your repository settings and add these secrets to prevent exposing them in your code.

#### Docker Integration

Containerizing your application with Docker can simplify deployment and ensure consistency across environments.

##### Creating a Dockerfile

```dockerfile
# FILE: Dockerfile
FROM denoland/deno:alpine-1.30.3

# Set working directory
WORKDIR /app

# Cache dependencies
COPY deps.ts .
RUN deno cache deps.ts

# Copy source code
COPY src/ ./src/
COPY cli.ts .

# Expose port (if your application listens on a port)
EXPOSE 8000

# Command to run the application
CMD ["run", "--allow-net", "--allow-read", "--allow-write", "src/main.ts"]
```

##### Building and Pushing the Docker Image

Add the following steps to your GitHub Actions workflow to build and push the Docker image to a container registry like Docker Hub.

```yaml
      docker-build-push:
        needs: build-and-test
        runs-on: ubuntu-latest
        steps:
          - uses: actions/checkout@v2

          - name: Log in to Docker Hub
            uses: docker/login-action@v2
            with:
              username: ${{ secrets.DOCKER_USERNAME }}
              password: ${{ secrets.DOCKER_PASSWORD }}

          - name: Build and Push Docker Image
            uses: docker/build-push-action@v4
            with:
              context: .
              push: true
              tags: yourdockerhubusername/rexorm-app:latest
```

**Explanation:**

- **Log in to Docker Hub**: Authenticates with Docker Hub using credentials stored in GitHub Secrets.
- **Build and Push Docker Image**: Builds the Docker image using the `Dockerfile` and pushes it to Docker Hub with the tag `latest`.

##### Deploying Docker Containers

On your deployment server, pull the latest Docker image and run the container.

```bash
# SSH into your server
ssh your_user@your_server_ip

# Pull the latest image
docker pull yourdockerhubusername/rexorm-app:latest

# Stop and remove the existing container if it exists
docker stop rexorm_app || true
docker rm rexorm_app || true

# Run the new container
docker run -d --name rexorm_app -p 8000:8000 yourdockerhubusername/rexorm-app:latest
```

### Step 9: Monitoring and Maintenance

Ensuring your application runs smoothly in production requires continuous monitoring and maintenance.

#### Implementing Health Checks

Health checks allow you to monitor the status of your application and respond to failures promptly.

```typescript
// FILE: src/main.ts
import { Repository } from "./models/Repository.ts";
import { User } from "./models/User.ts";
import { DatabaseFactory } from "./adapters/DatabaseFactory.ts";

const config = {
  type: "postgres",
  host: "localhost",
  user: "admin",
  password: "password",
  port: 5432,
  database: "rexorm_db",
  poolSize: 10,
};

const adapter = DatabaseFactory.createAdapter(config);
await adapter.connect();

const userRepo = new Repository<User>(adapter, User);

// Health Check Endpoint
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";

const handler = async (request: Request): Promise<Response> => {
  try {
    await adapter.execute("SELECT 1");
    return new Response("OK", { status: 200 });
  } catch {
    return new Response("Internal Server Error", { status: 500 });
  }
};

console.log("Server running on http://localhost:8000");
await serve(handler, { port: 8000 });
```

**Explanation:**

- **Health Check Endpoint**: Provides a simple HTTP endpoint that executes a trivial database query to verify connectivity. This endpoint can be used by monitoring tools to check the application's health.

#### Logging and Alerting

Ensure that all logs are stored and monitored effectively. Integrate with logging and alerting services to receive notifications about critical issues.

- **Log Aggregation**: Use services like ELK Stack (Elasticsearch, Logstash, Kibana) or cloud-based solutions like Datadog, Loggly, or Papertrail.
- **Alerting**: Set up alerts for specific log patterns or health check failures to respond promptly to incidents.

#### Regular Backups

Implement regular backups of your database to prevent data loss.

- **PostgreSQL**: Use `pg_dump` to create backups.
- **SQLite**: Regularly copy the `.sqlite` file to a secure location.

Automate backups using cron jobs or scheduled tasks in your CI/CD pipeline.

```bash
# Example cron job for PostgreSQL backup every day at 2 AM
0 2 * * * pg_dump -h localhost -U admin -F c rexorm_db > /backups/rexorm_db_$(date +\%F).dump
```

### Step 10: Contributing and Community Building

Encourage contributions and build a community around Rex-ORM to foster growth and improvement.

#### Contribution Guidelines

Create a `CONTRIBUTING.md` file outlining how developers can contribute to Rex-ORM.

```markdown
# Contributing to Rex-ORM

Thank you for considering contributing to Rex-ORM! We welcome contributions of all kinds.

## How to Contribute

1. **Fork the Repository**: Click the "Fork" button at the top of the repository page.
2. **Clone Your Fork**:
   ```bash
   git clone https://github.com/yourusername/rex-orm.git
   cd rex-orm
   ```
3. **Create a Branch**:
   ```bash
   git checkout -b feature/your-feature-name
   ```
4. **Make Your Changes**: Implement your feature or fix a bug.
5. **Run Tests**:
   ```bash
   deno test --allow-env --allow-net --allow-read --allow-write --coverage --config tsconfig.json
   ```
6. **Commit Your Changes**:
   ```bash
   git commit -m "Add your descriptive commit message"
   ```
7. **Push to Your Fork**:
   ```bash
   git push origin feature/your-feature-name
   ```
8. **Create a Pull Request**: Go to the original repository and click "New Pull Request".

## Code of Conduct

Please adhere to our [Code of Conduct](CODE_OF_CONDUCT.md) to ensure a welcoming and respectful environment for all contributors.

## Reporting Issues

If you encounter any issues, please open an issue in the [Issues](https://github.com/yourusername/rex-orm/issues) section with a detailed description and steps to reproduce.

## Style Guidelines

- Follow the existing code style.
- Write clear and concise commit messages.
- Ensure all tests pass before submitting a pull request.
```

#### Creating a Code of Conduct

Establish a `CODE_OF_CONDUCT.md` to promote a positive and inclusive community.

```markdown
# Code of Conduct

## Our Pledge

We are committed to fostering an open and welcoming environment for everyone. We pledge to treat everyone with respect and kindness.

## Our Standards

- **Be Respectful**: Respect differing viewpoints and experiences.
- **Be Considerate**: Assume good intentions and communicate thoughtfully.
- **Be Inclusive**: Encourage participation from all individuals.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the project team. We will investigate and take appropriate action.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant](https://www.contributor-covenant.org/).
```

#### Building a Community

- **Discussions**: Enable GitHub Discussions to allow users to ask questions and share ideas.
- **Documentation**: Continuously update and improve the `/docs` folder with comprehensive guides and examples.
- **Social Media and Forums**: Promote Rex-ORM on platforms like Twitter, Reddit, and Deno community forums.
- **Meetups and Webinars**: Host virtual meetups or webinars to engage with users and gather feedback.

### Conclusion

Rex-ORM aims to provide a robust, type-safe, and extensible ORM solution for Deno applications. By following this guide, you can set up, develop, and maintain your projects efficiently, leveraging powerful features like advanced relationship handling, comprehensive migration systems, and an extensible plugin architecture.

#### Next Steps

- **Explore Advanced Features**: Dive deeper into relationships, transactions, and performance optimizations.
- **Contribute to Rex-ORM**: Help improve Rex-ORM by contributing code, documentation, or feedback.
- **Stay Updated**: Follow the repository for updates, new features, and improvements.

#### Resources

- **Repository**: [https://github.com/yourusername/rex-orm](https://github.com/yourusername/rex-orm)
- **Documentation**: [https://github.com/yourusername/rex-orm/tree/main/docs](https://github.com/yourusername/rex-orm/tree/main/docs)
- **Community Discussions**: [https://github.com/yourusername/rex-orm/discussions](https://github.com/yourusername/rex-orm/discussions)

Thank you for choosing Rex-ORM! We look forward to seeing the amazing projects you build with it.
